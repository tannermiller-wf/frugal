// Autogenerated by Frugal Compiler (2.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(deprecated)]
#![allow(unused_imports)]

extern crate frugal;
extern crate rust;
extern crate thrift;
#[macro_use]
extern crate lazy_static;

#[allow(unused)]
use std::collections::{BTreeMap, BTreeSet};

pub const REDEF_CONST: i32 = rust::CONST_I32_FROM_BASE;

lazy_static! {
    pub static ref CONST_THING: rust::Thing = rust::Thing {
        an_id: Some(1),
        a_string: Some("some string".into()),
    };
}

pub const DEFAULT_ID: Id = -1;

pub const OTHER_DEFAULT: Id = DEFAULT_ID;

pub const THIRTYFOUR: i8 = 34;

lazy_static! {
    pub static ref MAPCONSTANT: BTreeMap<String, String> = {
        let mut m = BTreeMap::new();
        m.insert("hello".into(), "world".into());
        m.insert("goodnight".into(), "moon".into());
        m
    };
}

lazy_static! {
    pub static ref CONSTEVENT1: Event = Event {
        id: Some(-2),
        message: Some("first one".into()),
    };
}

lazy_static! {
    pub static ref CONSTEVENT2: Event = Event {
        id: Some(-7),
        message: Some("second one".into()),
    };
}

lazy_static! {
    pub static ref NUMSLIST: Vec<i32> = vec![2, 4, 7, 1];
}

lazy_static! {
    pub static ref NUMSSET: BTreeSet<Int> = {
        let mut s = BTreeSet::new();
        s.insert(1);
        s.insert(3);
        s.insert(8);
        s.insert(0);
        s
    };
}

lazy_static! {
    pub static ref MAPCONSTANT2: BTreeMap<String, Event> = {
        let mut m = BTreeMap::new();
        m.insert(
            "hello".into(),
            Event {
                id: Some(-2),
                message: Some("first here".into()),
            },
        );
        m
    };
}

lazy_static! {
    pub static ref BIN_CONST: Vec<u8> = b"hello".to_vec();
}

pub const TRUE_CONSTANT: bool = true;

pub const FALSE_CONSTANT: bool = false;

lazy_static! {
    pub static ref CONST_HC: HealthCondition = HealthCondition::Warn;
}

lazy_static! {
    pub static ref EVIL_STRING: String = "thin'g\" \"".into();
}

lazy_static! {
    pub static ref EVIL_STRING2: String = "th'ing\"ad\"f".into();
}

lazy_static! {
    pub static ref CONST_LOWER: TestLowercase = TestLowercase {
        lowercase_int: Some(2),
    };
}

pub type Id = i64;

pub type Int = i32;

pub type Request = BTreeMap<Int, String>;

pub type T1String = String;

pub type T2String = T1String;

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum HealthCondition {
    /// This docstring gets added to the generated code because it
    /// has the @ sign.
    Pass = 1,
    /// This docstring also gets added to the generated code
    /// because it has the @ sign.
    Warn = 2,
    #[deprecated(note = "use something else")]
    Fail = 3,
    /// This is a docstring comment for a deprecated enum value that has been
    /// spread across two lines.
    #[deprecated(note = "don't use this; use \"something else\"")]
    Unknown = 4,
}

impl HealthCondition {
    pub fn from_i32(i: i32) -> thrift::Result<HealthCondition> {
        match i {
            i if HealthCondition::Pass as i32 == i => Ok(HealthCondition::Pass),
            i if HealthCondition::Warn as i32 == i => Ok(HealthCondition::Warn),
            i if HealthCondition::Fail as i32 == i => Ok(HealthCondition::Fail),
            i if HealthCondition::Unknown as i32 == i => Ok(HealthCondition::Unknown),
            _ => Err(thrift::new_protocol_error(
                thrift::ProtocolErrorKind::InvalidData,
                format!("{} is not a valid integer value for HealthCondition", i),
            )),
        }
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum ItsAnEnum {
    First = 2,
    Second = 3,
    Third = 4,
    Fourth = 5,
    Fifth = 6,
    Sixith = 7,
}

impl ItsAnEnum {
    pub fn from_i32(i: i32) -> thrift::Result<ItsAnEnum> {
        match i {
            i if ItsAnEnum::First as i32 == i => Ok(ItsAnEnum::First),
            i if ItsAnEnum::Second as i32 == i => Ok(ItsAnEnum::Second),
            i if ItsAnEnum::Third as i32 == i => Ok(ItsAnEnum::Third),
            i if ItsAnEnum::Fourth as i32 == i => Ok(ItsAnEnum::Fourth),
            i if ItsAnEnum::Fifth as i32 == i => Ok(ItsAnEnum::Fifth),
            i if ItsAnEnum::Sixith as i32 == i => Ok(ItsAnEnum::Sixith),
            _ => Err(thrift::new_protocol_error(
                thrift::ProtocolErrorKind::InvalidData,
                format!("{} is not a valid integer value for ItsAnEnum", i),
            )),
        }
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct TestBase {
    pub base_struct: Option<rust::Thing>,
}

impl TestBase {
    pub fn new() -> TestBase {
        TestBase { base_struct: None }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let mut base_struct = rust::Thing::new();
        base_struct.read(iprot)?;
        self.base_struct = Some(base_struct);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "TestBase".into(),
        })?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let base_struct = match self.base_struct {
            Some(ref base_struct) => base_struct,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("base_struct".into()),
            field_type: thrift::protocol::TType::Struct,
            id: Some(1),
        })?;
        base_struct.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct TestLowercase {
    pub lowercase_int: Option<i32>,
}

impl TestLowercase {
    pub fn new() -> TestLowercase {
        TestLowercase {
            lowercase_int: None,
        }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let lowercase_int = iprot.read_i32()?;
        self.lowercase_int = Some(lowercase_int);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "TestLowercase".into(),
        })?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let lowercase_int = match self.lowercase_int {
            Some(lowercase_int) => lowercase_int,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("lowercaseInt".into()),
            field_type: thrift::protocol::TType::I32,
            id: Some(1),
        })?;
        oprot.write_i32(lowercase_int)?;
        oprot.write_field_end()
    }
}

/// This docstring gets added to the generated code because it has
/// the @ sign.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct Event {
    /// ID is a unique identifier for an event.
    pub id: Option<Id>,
    /// Message contains the event payload.
    pub message: Option<String>,
}

impl Event {
    pub fn new() -> Event {
        Event {
            id: Some(DEFAULT_ID),
            message: None,
        }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let id = iprot.read_i64()?;
        self.id = Some(id);
        Ok(())
    }

    fn read_field_2<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let message = iprot.read_string()?;
        self.message = Some(message);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "Event".into(),
        })?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let id = match self.id {
            Some(id) => id,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ID".into()),
            field_type: thrift::protocol::TType::I64,
            id: Some(1),
        })?;
        oprot.write_i64(id)?;
        oprot.write_field_end()
    }

    fn write_field_2<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let message = match self.message {
            Some(ref message) => message,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Message".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(2),
        })?;
        oprot.write_string(message)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct TestingDefaults {
    pub id2: Option<Id>,
    pub ev1: Option<Event>,
    pub ev2: Option<Event>,
    pub id: Option<Id>,
    pub thing: Option<String>,
    pub thing2: Option<String>,
    pub listfield: Option<Vec<Int>>,
    pub id3: Option<Id>,
    pub bin_field: Option<Vec<u8>>,
    pub bin_field2: Option<Vec<u8>>,
    pub bin_field3: Option<Vec<u8>>,
    pub bin_field4: Option<Vec<u8>>,
    pub list2: Option<Vec<Int>>,
    pub list3: Option<Vec<Int>>,
    pub list4: Option<Vec<Int>>,
    pub a_map: Option<BTreeMap<String, String>>,
    pub status: HealthCondition,
    pub base_status: rust::BaseHealthCondition,
}

impl TestingDefaults {
    pub fn new() -> TestingDefaults {
        TestingDefaults {
            id2: Some(DEFAULT_ID),
            ev1: Some(Event {
                id: Some(DEFAULT_ID),
                message: Some("a message".into()),
            }),
            ev2: Some(Event {
                id: Some(5),
                message: Some("a message2".into()),
            }),
            id: Some(-2),
            thing: Some("a constant".into()),
            thing2: Some("another constant".into()),
            listfield: Some(vec![1, 2, 3, 4, 5]),
            id3: Some(OTHER_DEFAULT),
            bin_field: None,
            bin_field2: None,
            bin_field3: None,
            bin_field4: Some(BIN_CONST.clone()),
            list2: Some(vec![1, 3, 4, 5, 8]),
            list3: None,
            list4: Some(vec![1, 2, 3, 6]),
            a_map: Some({
                let mut m = BTreeMap::new();
                m.insert("k1".into(), "v1".into());
                m.insert("k2".into(), "v2".into());
                m
            }),
            status: HealthCondition::Pass,
            base_status: rust::BaseHealthCondition::Fail,
        }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                Some(3) => self.read_field_3(iprot)?,
                Some(4) => self.read_field_4(iprot)?,
                Some(5) => self.read_field_5(iprot)?,
                Some(6) => self.read_field_6(iprot)?,
                Some(7) => self.read_field_7(iprot)?,
                Some(8) => self.read_field_8(iprot)?,
                Some(9) => self.read_field_9(iprot)?,
                Some(10) => self.read_field_10(iprot)?,
                Some(11) => self.read_field_11(iprot)?,
                Some(12) => self.read_field_12(iprot)?,
                Some(13) => self.read_field_13(iprot)?,
                Some(14) => self.read_field_14(iprot)?,
                Some(15) => self.read_field_15(iprot)?,
                Some(16) => self.read_field_16(iprot)?,
                Some(17) => self.read_field_17(iprot)?,
                Some(18) => self.read_field_18(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let id2 = iprot.read_i64()?;
        self.id2 = Some(id2);
        Ok(())
    }

    fn read_field_2<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let mut ev1 = Event::new();
        ev1.read(iprot)?;
        self.ev1 = Some(ev1);
        Ok(())
    }

    fn read_field_3<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let mut ev2 = Event::new();
        ev2.read(iprot)?;
        self.ev2 = Some(ev2);
        Ok(())
    }

    fn read_field_4<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let id = iprot.read_i64()?;
        self.id = Some(id);
        Ok(())
    }

    fn read_field_5<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let thing = iprot.read_string()?;
        self.thing = Some(thing);
        Ok(())
    }

    fn read_field_6<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let thing2 = iprot.read_string()?;
        self.thing2 = Some(thing2);
        Ok(())
    }

    fn read_field_7<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut listfield = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let listfield_item = iprot.read_i32()?;
            listfield.push(listfield_item);
        }
        iprot.read_list_end()?;
        self.listfield = Some(listfield);
        Ok(())
    }

    fn read_field_8<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let id3 = iprot.read_i64()?;
        self.id3 = Some(id3);
        Ok(())
    }

    fn read_field_9<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let bin_field = iprot.read_bytes()?;
        self.bin_field = Some(bin_field);
        Ok(())
    }

    fn read_field_10<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let bin_field2 = iprot.read_bytes()?;
        self.bin_field2 = Some(bin_field2);
        Ok(())
    }

    fn read_field_11<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let bin_field3 = iprot.read_bytes()?;
        self.bin_field3 = Some(bin_field3);
        Ok(())
    }

    fn read_field_12<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let bin_field4 = iprot.read_bytes()?;
        self.bin_field4 = Some(bin_field4);
        Ok(())
    }

    fn read_field_13<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut list2 = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let list2_item = iprot.read_i32()?;
            list2.push(list2_item);
        }
        iprot.read_list_end()?;
        self.list2 = Some(list2);
        Ok(())
    }

    fn read_field_14<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut list3 = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let list3_item = iprot.read_i32()?;
            list3.push(list3_item);
        }
        iprot.read_list_end()?;
        self.list3 = Some(list3);
        Ok(())
    }

    fn read_field_15<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut list4 = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let list4_item = iprot.read_i32()?;
            list4.push(list4_item);
        }
        iprot.read_list_end()?;
        self.list4 = Some(list4);
        Ok(())
    }

    fn read_field_16<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let map_id = iprot.read_map_begin()?;
        let mut a_map = BTreeMap::new();
        for _ in 0..map_id.size {
            let a_map_key = iprot.read_string()?;
            let a_map_value = iprot.read_string()?;
            a_map.insert(a_map_key, a_map_value);
        }
        iprot.read_map_end()?;
        self.a_map = Some(a_map);
        Ok(())
    }

    fn read_field_17<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let status = iprot.read_i32().and_then(HealthCondition::from_i32)?;
        self.status = status;
        Ok(())
    }

    fn read_field_18<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let base_status = iprot
            .read_i32()
            .and_then(rust::BaseHealthCondition::from_i32)?;
        self.base_status = base_status;
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "TestingDefaults".into(),
        })?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        self.write_field_3(oprot)?;
        self.write_field_4(oprot)?;
        self.write_field_5(oprot)?;
        self.write_field_6(oprot)?;
        self.write_field_7(oprot)?;
        self.write_field_8(oprot)?;
        self.write_field_9(oprot)?;
        self.write_field_10(oprot)?;
        self.write_field_11(oprot)?;
        self.write_field_12(oprot)?;
        self.write_field_13(oprot)?;
        self.write_field_14(oprot)?;
        self.write_field_15(oprot)?;
        self.write_field_16(oprot)?;
        self.write_field_17(oprot)?;
        self.write_field_18(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let id2 = match self.id2 {
            Some(id2) => id2,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ID2".into()),
            field_type: thrift::protocol::TType::I64,
            id: Some(1),
        })?;
        oprot.write_i64(id2)?;
        oprot.write_field_end()
    }

    fn write_field_2<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let ev1 = match self.ev1 {
            Some(ref ev1) => ev1,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ev1".into()),
            field_type: thrift::protocol::TType::Struct,
            id: Some(2),
        })?;
        ev1.write(oprot)?;
        oprot.write_field_end()
    }

    fn write_field_3<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let ev2 = match self.ev2 {
            Some(ref ev2) => ev2,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ev2".into()),
            field_type: thrift::protocol::TType::Struct,
            id: Some(3),
        })?;
        ev2.write(oprot)?;
        oprot.write_field_end()
    }

    fn write_field_4<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let id = match self.id {
            Some(id) => id,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ID".into()),
            field_type: thrift::protocol::TType::I64,
            id: Some(4),
        })?;
        oprot.write_i64(id)?;
        oprot.write_field_end()
    }

    fn write_field_5<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let thing = match self.thing {
            Some(ref thing) => thing,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("thing".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(5),
        })?;
        oprot.write_string(thing)?;
        oprot.write_field_end()
    }

    fn write_field_6<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let thing2 = match self.thing2 {
            Some(ref thing2) => thing2,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("thing2".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(6),
        })?;
        oprot.write_string(thing2)?;
        oprot.write_field_end()
    }

    fn write_field_7<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let listfield = match self.listfield {
            Some(ref listfield) => listfield,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("listfield".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(7),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::I32,
            size: listfield.len() as i32,
        })?;
        for listfield_item in listfield {
            oprot.write_i32(*listfield_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_8<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let id3 = match self.id3 {
            Some(id3) => id3,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ID3".into()),
            field_type: thrift::protocol::TType::I64,
            id: Some(8),
        })?;
        oprot.write_i64(id3)?;
        oprot.write_field_end()
    }

    fn write_field_9<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let bin_field = match self.bin_field {
            Some(ref bin_field) => bin_field,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("bin_field".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(9),
        })?;
        oprot.write_bytes(bin_field)?;
        oprot.write_field_end()
    }

    fn write_field_10<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let bin_field2 = match self.bin_field2 {
            Some(ref bin_field2) => bin_field2,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("bin_field2".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(10),
        })?;
        oprot.write_bytes(bin_field2)?;
        oprot.write_field_end()
    }

    fn write_field_11<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let bin_field3 = match self.bin_field3 {
            Some(ref bin_field3) => bin_field3,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("bin_field3".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(11),
        })?;
        oprot.write_bytes(bin_field3)?;
        oprot.write_field_end()
    }

    fn write_field_12<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let bin_field4 = match self.bin_field4 {
            Some(ref bin_field4) => bin_field4,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("bin_field4".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(12),
        })?;
        oprot.write_bytes(bin_field4)?;
        oprot.write_field_end()
    }

    fn write_field_13<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let list2 = match self.list2 {
            Some(ref list2) => list2,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("list2".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(13),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::I32,
            size: list2.len() as i32,
        })?;
        for list2_item in list2 {
            oprot.write_i32(*list2_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_14<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let list3 = match self.list3 {
            Some(ref list3) => list3,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("list3".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(14),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::I32,
            size: list3.len() as i32,
        })?;
        for list3_item in list3 {
            oprot.write_i32(*list3_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_15<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let list4 = match self.list4 {
            Some(ref list4) => list4,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("list4".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(15),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::I32,
            size: list4.len() as i32,
        })?;
        for list4_item in list4 {
            oprot.write_i32(*list4_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_16<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let a_map = match self.a_map {
            Some(ref a_map) => a_map,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("a_map".into()),
            field_type: thrift::protocol::TType::Map,
            id: Some(16),
        })?;
        oprot.write_map_begin(&thrift::protocol::TMapIdentifier {
            key_type: Some(thrift::protocol::TType::String),
            value_type: Some(thrift::protocol::TType::String),
            size: a_map.len() as i32,
        })?;
        for (a_map_key, a_map_value) in a_map {
            oprot.write_string(a_map_key)?;
            oprot.write_string(a_map_value)?;
        }
        oprot.write_map_end()?;
        oprot.write_field_end()
    }

    fn write_field_17<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let status = &self.status;
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("status".into()),
            field_type: thrift::protocol::TType::I32,
            id: Some(17),
        })?;
        oprot.write_i32(status.clone() as i32)?;
        oprot.write_field_end()
    }

    fn write_field_18<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let base_status = &self.base_status;
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("base_status".into()),
            field_type: thrift::protocol::TType::I32,
            id: Some(18),
        })?;
        oprot.write_i32(base_status.clone() as i32)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct EventWrapper {
    pub id: Option<Id>,
    pub ev: Event,
    pub events: Option<Vec<Event>>,
    pub events2: Option<BTreeSet<Event>>,
    pub event_map: Option<BTreeMap<Id, Event>>,
    pub nums: Option<Vec<Vec<Int>>>,
    pub enums: Option<Vec<ItsAnEnum>>,
    pub a_bool_field: Option<bool>,
    pub a_union: Option<TestingUnions>,
    pub typedef_of_typedef: Option<T2String>,
    /// This is a docstring comment for a deprecated field that has been spread
    /// across two lines.
    #[deprecated(note = "use something else")]
    pub depr: Option<bool>,
    #[deprecated(note = "use something else")]
    pub depr_binary: Option<Vec<u8>>,
    #[deprecated(note = "use something else")]
    pub depr_list: Option<Vec<bool>>,
}

impl EventWrapper {
    pub fn new() -> EventWrapper {
        EventWrapper {
            id: None,
            ev: Event::new(),
            events: None,
            events2: None,
            event_map: None,
            nums: None,
            enums: None,
            a_bool_field: None,
            a_union: None,
            typedef_of_typedef: None,
            depr: None,
            depr_binary: None,
            depr_list: None,
        }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                Some(3) => self.read_field_3(iprot)?,
                Some(4) => self.read_field_4(iprot)?,
                Some(5) => self.read_field_5(iprot)?,
                Some(6) => self.read_field_6(iprot)?,
                Some(7) => self.read_field_7(iprot)?,
                Some(8) => self.read_field_8(iprot)?,
                Some(9) => self.read_field_9(iprot)?,
                Some(10) => self.read_field_10(iprot)?,
                Some(11) => self.read_field_11(iprot)?,
                Some(12) => self.read_field_12(iprot)?,
                Some(13) => self.read_field_13(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let id = iprot.read_i64()?;
        self.id = Some(id);
        Ok(())
    }

    fn read_field_2<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let mut ev = Event::new();
        ev.read(iprot)?;
        self.ev = ev;
        Ok(())
    }

    fn read_field_3<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut events = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let mut events_item = Event::new();
            events_item.read(iprot)?;
            events.push(events_item);
        }
        iprot.read_list_end()?;
        self.events = Some(events);
        Ok(())
    }

    fn read_field_4<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let set_id = iprot.read_set_begin()?;
        let mut events2 = BTreeSet::new();
        for _ in 0..set_id.size {
            let mut events2_item = Event::new();
            events2_item.read(iprot)?;
            events2.insert(events2_item);
        }
        iprot.read_set_end()?;
        self.events2 = Some(events2);
        Ok(())
    }

    fn read_field_5<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let map_id = iprot.read_map_begin()?;
        let mut event_map = BTreeMap::new();
        for _ in 0..map_id.size {
            let event_map_key = iprot.read_i64()?;
            let mut event_map_value = Event::new();
            event_map_value.read(iprot)?;
            event_map.insert(event_map_key, event_map_value);
        }
        iprot.read_map_end()?;
        self.event_map = Some(event_map);
        Ok(())
    }

    fn read_field_6<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut nums = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let list_id = iprot.read_list_begin()?;
            let mut nums_item = Vec::with_capacity(list_id.size as usize);
            for _ in 0..list_id.size {
                let nums_item_item = iprot.read_i32()?;
                nums_item.push(nums_item_item);
            }
            iprot.read_list_end()?;
            nums.push(nums_item);
        }
        iprot.read_list_end()?;
        self.nums = Some(nums);
        Ok(())
    }

    fn read_field_7<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut enums = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let enums_item = iprot.read_i32().and_then(ItsAnEnum::from_i32)?;
            enums.push(enums_item);
        }
        iprot.read_list_end()?;
        self.enums = Some(enums);
        Ok(())
    }

    fn read_field_8<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let a_bool_field = iprot.read_bool()?;
        self.a_bool_field = Some(a_bool_field);
        Ok(())
    }

    fn read_field_9<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let mut a_union = TestingUnions::AnID(0);
        a_union.read(iprot)?;
        self.a_union = Some(a_union);
        Ok(())
    }

    fn read_field_10<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let typedef_of_typedef = iprot.read_string()?;
        self.typedef_of_typedef = Some(typedef_of_typedef);
        Ok(())
    }

    fn read_field_11<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let depr = iprot.read_bool()?;
        self.depr = Some(depr);
        Ok(())
    }

    fn read_field_12<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let depr_binary = iprot.read_bytes()?;
        self.depr_binary = Some(depr_binary);
        Ok(())
    }

    fn read_field_13<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let list_id = iprot.read_list_begin()?;
        let mut depr_list = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let depr_list_item = iprot.read_bool()?;
            depr_list.push(depr_list_item);
        }
        iprot.read_list_end()?;
        self.depr_list = Some(depr_list);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "EventWrapper".into(),
        })?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        self.write_field_3(oprot)?;
        self.write_field_4(oprot)?;
        self.write_field_5(oprot)?;
        self.write_field_6(oprot)?;
        self.write_field_7(oprot)?;
        self.write_field_8(oprot)?;
        self.write_field_9(oprot)?;
        self.write_field_10(oprot)?;
        self.write_field_11(oprot)?;
        self.write_field_12(oprot)?;
        self.write_field_13(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let id = match self.id {
            Some(id) => id,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ID".into()),
            field_type: thrift::protocol::TType::I64,
            id: Some(1),
        })?;
        oprot.write_i64(id)?;
        oprot.write_field_end()
    }

    fn write_field_2<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let ev = &self.ev;
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Ev".into()),
            field_type: thrift::protocol::TType::Struct,
            id: Some(2),
        })?;
        ev.write(oprot)?;
        oprot.write_field_end()
    }

    fn write_field_3<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let events = match self.events {
            Some(ref events) => events,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Events".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(3),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::Struct,
            size: events.len() as i32,
        })?;
        for events_item in events {
            events_item.write(oprot)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_4<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let events2 = match self.events2 {
            Some(ref events2) => events2,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Events2".into()),
            field_type: thrift::protocol::TType::Set,
            id: Some(4),
        })?;
        oprot.write_set_begin(&thrift::protocol::TSetIdentifier {
            element_type: thrift::protocol::TType::Struct,
            size: events2.len() as i32,
        })?;
        for events2_item in events2 {
            events2_item.write(oprot)?;
        }
        oprot.write_set_end()?;
        oprot.write_field_end()
    }

    fn write_field_5<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let event_map = match self.event_map {
            Some(ref event_map) => event_map,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("EventMap".into()),
            field_type: thrift::protocol::TType::Map,
            id: Some(5),
        })?;
        oprot.write_map_begin(&thrift::protocol::TMapIdentifier {
            key_type: Some(thrift::protocol::TType::I64),
            value_type: Some(thrift::protocol::TType::Struct),
            size: event_map.len() as i32,
        })?;
        for (event_map_key, event_map_value) in event_map {
            oprot.write_i64(*event_map_key)?;
            event_map_value.write(oprot)?;
        }
        oprot.write_map_end()?;
        oprot.write_field_end()
    }

    fn write_field_6<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let nums = match self.nums {
            Some(ref nums) => nums,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Nums".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(6),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::List,
            size: nums.len() as i32,
        })?;
        for nums_item in nums {
            oprot.write_list_begin(&thrift::protocol::TListIdentifier {
                element_type: thrift::protocol::TType::I32,
                size: nums_item.len() as i32,
            })?;
            for nums_item_item in nums_item {
                oprot.write_i32(*nums_item_item)?;
            }
            oprot.write_list_end()?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_7<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let enums = match self.enums {
            Some(ref enums) => enums,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Enums".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(7),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::I32,
            size: enums.len() as i32,
        })?;
        for enums_item in enums {
            oprot.write_i32(enums_item.clone() as i32)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_8<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let a_bool_field = match self.a_bool_field {
            Some(a_bool_field) => a_bool_field,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("aBoolField".into()),
            field_type: thrift::protocol::TType::Bool,
            id: Some(8),
        })?;
        oprot.write_bool(a_bool_field)?;
        oprot.write_field_end()
    }

    fn write_field_9<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let a_union = match self.a_union {
            Some(ref a_union) => a_union,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("a_union".into()),
            field_type: thrift::protocol::TType::Struct,
            id: Some(9),
        })?;
        a_union.write(oprot)?;
        oprot.write_field_end()
    }

    fn write_field_10<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let typedef_of_typedef = match self.typedef_of_typedef {
            Some(ref typedef_of_typedef) => typedef_of_typedef,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("typedefOfTypedef".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(10),
        })?;
        oprot.write_string(typedef_of_typedef)?;
        oprot.write_field_end()
    }

    fn write_field_11<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let depr = match self.depr {
            Some(depr) => depr,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("depr".into()),
            field_type: thrift::protocol::TType::Bool,
            id: Some(11),
        })?;
        oprot.write_bool(depr)?;
        oprot.write_field_end()
    }

    fn write_field_12<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let depr_binary = match self.depr_binary {
            Some(ref depr_binary) => depr_binary,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("deprBinary".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(12),
        })?;
        oprot.write_bytes(depr_binary)?;
        oprot.write_field_end()
    }

    fn write_field_13<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let depr_list = match self.depr_list {
            Some(ref depr_list) => depr_list,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("deprList".into()),
            field_type: thrift::protocol::TType::List,
            id: Some(13),
        })?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier {
            element_type: thrift::protocol::TType::Bool,
            size: depr_list.len() as i32,
        })?;
        for depr_list_item in depr_list {
            oprot.write_bool(*depr_list_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct FooArgs {
    pub new_message: Option<String>,
    pub message_args: Option<String>,
    pub message_result: Option<String>,
}

impl FooArgs {
    pub fn new() -> FooArgs {
        FooArgs {
            new_message: None,
            message_args: None,
            message_result: None,
        }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                Some(3) => self.read_field_3(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let new_message = iprot.read_string()?;
        self.new_message = Some(new_message);
        Ok(())
    }

    fn read_field_2<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let message_args = iprot.read_string()?;
        self.message_args = Some(message_args);
        Ok(())
    }

    fn read_field_3<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let message_result = iprot.read_string()?;
        self.message_result = Some(message_result);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "FooArgs".into(),
        })?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        self.write_field_3(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let new_message = match self.new_message {
            Some(ref new_message) => new_message,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("newMessage".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(1),
        })?;
        oprot.write_string(new_message)?;
        oprot.write_field_end()
    }

    fn write_field_2<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let message_args = match self.message_args {
            Some(ref message_args) => message_args,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("messageArgs".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(2),
        })?;
        oprot.write_string(message_args)?;
        oprot.write_field_end()
    }

    fn write_field_3<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let message_result = match self.message_result {
            Some(ref message_result) => message_result,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("messageResult".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(3),
        })?;
        oprot.write_string(message_result)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum TestingUnions {
    AnID(Id),
    AString(String),
    Someotherthing(Int),
    AnInt16(i16),
    Requests(Request),
    BinFieldInUnion(Vec<u8>),
    #[deprecated(note = "use something else")]
    Depr(bool),
}

impl TestingUnions {
    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        let mut is_set = false;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            if is_set {
                return Err(thrift::new_protocol_error(
                    thrift::ProtocolErrorKind::InvalidData,
                    "TestingUnions read union: exactly one field must be set.",
                ));
            };
            match field_id.id {
                Some(1) => {
                    self.read_field_1(iprot)?;
                    is_set = true;
                }
                Some(2) => {
                    self.read_field_2(iprot)?;
                    is_set = true;
                }
                Some(3) => {
                    self.read_field_3(iprot)?;
                    is_set = true;
                }
                Some(4) => {
                    self.read_field_4(iprot)?;
                    is_set = true;
                }
                Some(5) => {
                    self.read_field_5(iprot)?;
                    is_set = true;
                }
                Some(6) => {
                    self.read_field_6(iprot)?;
                    is_set = true;
                }
                Some(7) => {
                    self.read_field_7(iprot)?;
                    is_set = true;
                }
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()?;
        if !is_set {
            return Err(thrift::new_protocol_error(
                thrift::ProtocolErrorKind::InvalidData,
                "no field for union was sent",
            ));
        };
        Ok(())
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let an_id = iprot.read_i64()?;
        *self = TestingUnions::AnID(an_id);
        Ok(())
    }

    fn read_field_2<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let a_string = iprot.read_string()?;
        *self = TestingUnions::AString(a_string);
        Ok(())
    }

    fn read_field_3<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let someotherthing = iprot.read_i32()?;
        *self = TestingUnions::Someotherthing(someotherthing);
        Ok(())
    }

    fn read_field_4<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let an_int16 = iprot.read_i16()?;
        *self = TestingUnions::AnInt16(an_int16);
        Ok(())
    }

    fn read_field_5<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let map_id = iprot.read_map_begin()?;
        let mut requests = BTreeMap::new();
        for _ in 0..map_id.size {
            let requests_key = iprot.read_i32()?;
            let requests_value = iprot.read_string()?;
            requests.insert(requests_key, requests_value);
        }
        iprot.read_map_end()?;
        *self = TestingUnions::Requests(requests);
        Ok(())
    }

    fn read_field_6<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let bin_field_in_union = iprot.read_bytes()?;
        *self = TestingUnions::BinFieldInUnion(bin_field_in_union);
        Ok(())
    }

    fn read_field_7<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let depr = iprot.read_bool()?;
        *self = TestingUnions::Depr(depr);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "TestingUnions".into(),
        })?;
        match self {
            TestingUnions::AnID(an_id) => {
                oprot.write_i64(*an_id)?;
            }
            TestingUnions::AString(a_string) => {
                oprot.write_string(a_string)?;
            }
            TestingUnions::Someotherthing(someotherthing) => {
                oprot.write_i32(*someotherthing)?;
            }
            TestingUnions::AnInt16(an_int16) => {
                oprot.write_i16(*an_int16)?;
            }
            TestingUnions::Requests(requests) => {
                oprot.write_map_begin(&thrift::protocol::TMapIdentifier {
                    key_type: Some(thrift::protocol::TType::I32),
                    value_type: Some(thrift::protocol::TType::String),
                    size: requests.len() as i32,
                })?;
                for (requests_key, requests_value) in requests {
                    oprot.write_i32(*requests_key)?;
                    oprot.write_string(requests_value)?;
                }
                oprot.write_map_end()?;
            }
            TestingUnions::BinFieldInUnion(bin_field_in_union) => {
                oprot.write_bytes(bin_field_in_union)?;
            }
            TestingUnions::Depr(depr) => {
                oprot.write_bool(*depr)?;
            }
        };
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct AwesomeException {
    /// ID is a unique identifier for an awesome exception.
    pub id: Option<Id>,
    /// Reason contains the error message.
    pub reason: Option<String>,
    #[deprecated(note = "use something else")]
    pub depr: Option<bool>,
}

impl AwesomeException {
    pub fn new() -> AwesomeException {
        AwesomeException {
            id: None,
            reason: None,
            depr: None,
        }
    }

    pub fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                Some(3) => self.read_field_3(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let id = iprot.read_i64()?;
        self.id = Some(id);
        Ok(())
    }

    fn read_field_2<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let reason = iprot.read_string()?;
        self.reason = Some(reason);
        Ok(())
    }

    fn read_field_3<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        let depr = iprot.read_bool()?;
        self.depr = Some(depr);
        Ok(())
    }

    pub fn write<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier {
            name: "AwesomeException".into(),
        })?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        self.write_field_3(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let id = match self.id {
            Some(id) => id,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("ID".into()),
            field_type: thrift::protocol::TType::I64,
            id: Some(1),
        })?;
        oprot.write_i64(id)?;
        oprot.write_field_end()
    }

    fn write_field_2<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let reason = match self.reason {
            Some(ref reason) => reason,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("Reason".into()),
            field_type: thrift::protocol::TType::String,
            id: Some(2),
        })?;
        oprot.write_string(reason)?;
        oprot.write_field_end()
    }

    fn write_field_3<T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TOutputProtocol,
    {
        let depr = match self.depr {
            Some(depr) => depr,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier {
            name: Some("depr".into()),
            field_type: thrift::protocol::TType::Bool,
            id: Some(3),
        })?;
        oprot.write_bool(depr)?;
        oprot.write_field_end()
    }
}

impl std::error::Error for AwesomeException {}

impl std::fmt::Display for AwesomeException {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

pub mod events_scope;
pub mod foo_service;
pub mod footransitivedeps_service;
