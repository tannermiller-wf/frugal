// Autogenerated by Frugal Compiler (2.23.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_variables)]

use std::collections::BTreeMap;
use std::error::Error;

use futures::future::{self, FutureResult};
use futures::{Async, Future, Poll};
use thrift;
use thrift::protocol::{TInputProtocol, TOutputProtocol};
use tower_service::Service;
use tower_web::middleware::{self, Middleware};
use tower_web::util::Chain;

use frugal::buffer::FMemoryOutputBuffer;
use frugal::context::{FContext, OP_ID_HEADER};
use frugal::errors;
use frugal::processor::FProcessor;
use frugal::protocol::{
    FInputProtocol, FInputProtocolFactory, FOutputProtocol, FOutputProtocolFactory,
};
use frugal::provider::FServiceProvider;
use frugal::transport::FTransport;

use super::*;
use actual_base_rust;
use intermediate_include;
use subdir_include;
use valid_structs;
use valid_types;

/// This is a thrift service. Frugal will generate bindings that include
/// a frugal Context for each service call.
pub trait FFoo: actual_base_rust::basefoo_service::FBaseFoo {
    /// Ping the server.
    #[deprecated(note = "don't use this; use \"something else\"")]
    fn ping(&mut self, ctx: &FContext) -> thrift::Result<()>;

    /// Blah the server.
    fn blah(
        &mut self,
        ctx: &FContext,
        num: Option<i32>,
        str: Option<String>,
        event: Option<Event>,
    ) -> thrift::Result<i64>;

    /// oneway methods don't receive a response from the server.
    fn one_way(
        &mut self,
        ctx: &FContext,
        id: Option<Id>,
        req: Option<Request>,
    ) -> thrift::Result<()>;

    fn bin_method(
        &mut self,
        ctx: &FContext,
        bin: Option<Vec<u8>>,
        str: Option<String>,
    ) -> thrift::Result<Vec<u8>>;

    fn param_modifiers(
        &mut self,
        ctx: &FContext,
        opt_num: Option<i32>,
        default_num: Option<i32>,
        req_num: i32,
    ) -> thrift::Result<i64>;

    fn underlying_types_test(
        &mut self,
        ctx: &FContext,
        list_type: Option<Vec<Id>>,
        set_type: Option<BTreeSet<Id>>,
    ) -> thrift::Result<Vec<Id>>;

    fn get_thing(&mut self, ctx: &FContext) -> thrift::Result<valid_structs::Thing>;

    fn get_my_int(&mut self, ctx: &FContext) -> thrift::Result<valid_types::MyInt>;

    fn use_subdir_struct(
        &mut self,
        ctx: &FContext,
        a: Option<subdir_include::A>,
    ) -> thrift::Result<subdir_include::A>;

    fn say_hello_with(
        &mut self,
        ctx: &FContext,
        new_message: Option<String>,
    ) -> thrift::Result<String>;

    fn what_do_you_say(
        &mut self,
        ctx: &FContext,
        message_args: Option<String>,
    ) -> thrift::Result<String>;

    fn say_again(
        &mut self,
        ctx: &FContext,
        message_result: Option<String>,
    ) -> thrift::Result<String>;
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooPingArgs {}

impl FFooPingArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("Ping_args"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooPingResult {}

impl FFooPingResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("Ping_result"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooBlahArgs {
    pub num: Option<i32>,
    pub str: Option<String>,
    pub event: Option<Event>,
}

impl FFooBlahArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                Some(3) => self.read_field_3(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let num = iprot.read_i32()?;
        self.num = Some(num);
        Ok(())
    }

    fn read_field_2<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let str = iprot.read_string()?;
        self.str = Some(str);
        Ok(())
    }

    fn read_field_3<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut event = Event::default();
        event.read(iprot)?;
        self.event = Some(event);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("blah_args"))?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        self.write_field_3(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let num = match self.num {
            Some(num) => num,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "num",
            thrift::protocol::TType::I32,
            1,
        ))?;
        oprot.write_i32(num)?;
        oprot.write_field_end()
    }

    fn write_field_2<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let str = match self.str {
            Some(ref str) => str,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Str",
            thrift::protocol::TType::String,
            2,
        ))?;
        oprot.write_string(str)?;
        oprot.write_field_end()
    }

    fn write_field_3<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let event = match self.event {
            Some(ref event) => event,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "event",
            thrift::protocol::TType::Struct,
            3,
        ))?;
        event.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooBlahResult {
    pub success: Option<i64>,
    pub awe: Option<AwesomeException>,
    pub api: Option<actual_base_rust::ApiException>,
}

impl FFooBlahResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_i64()?;
        self.success = Some(success);
        Ok(())
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut awe = AwesomeException::default();
        awe.read(iprot)?;
        self.awe = Some(awe);
        Ok(())
    }

    fn read_field_2<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut api = actual_base_rust::ApiException::default();
        api.read(iprot)?;
        self.api = Some(api);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("blah_result"))?;
        self.write_field_0(oprot)?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::I64,
            0,
        ))?;
        oprot.write_i64(success)?;
        oprot.write_field_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let awe = match self.awe {
            Some(ref awe) => awe,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "awe",
            thrift::protocol::TType::Struct,
            1,
        ))?;
        awe.write(oprot)?;
        oprot.write_field_end()
    }

    fn write_field_2<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let api = match self.api {
            Some(ref api) => api,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "api",
            thrift::protocol::TType::Struct,
            2,
        ))?;
        api.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooOneWayArgs {
    pub id: Option<Id>,
    pub req: Option<Request>,
}

impl FFooOneWayArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let id = iprot.read_i64()?;
        self.id = Some(id);
        Ok(())
    }

    fn read_field_2<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let map_id = iprot.read_map_begin()?;
        let mut req = BTreeMap::new();
        for _ in 0..map_id.size {
            let req_key = iprot.read_i32()?;
            let req_value = iprot.read_string()?;
            req.insert(req_key, req_value);
        }
        iprot.read_map_end()?;
        self.req = Some(req);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("oneWay_args"))?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let id = match self.id {
            Some(id) => id,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "id",
            thrift::protocol::TType::I64,
            1,
        ))?;
        oprot.write_i64(id)?;
        oprot.write_field_end()
    }

    fn write_field_2<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let req = match self.req {
            Some(ref req) => req,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "req",
            thrift::protocol::TType::Map,
            2,
        ))?;
        oprot.write_map_begin(&thrift::protocol::TMapIdentifier::new(
            thrift::protocol::TType::I32,
            thrift::protocol::TType::String,
            req.len() as i32,
        ))?;
        for (req_key, req_value) in req {
            oprot.write_i32(*req_key)?;
            oprot.write_string(req_value)?;
        }
        oprot.write_map_end()?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooOneWayResult {}

impl FFooOneWayResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("oneWay_result"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooBinMethodArgs {
    pub bin: Option<Vec<u8>>,
    pub str: Option<String>,
}

impl FFooBinMethodArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let bin = iprot.read_bytes()?;
        self.bin = Some(bin);
        Ok(())
    }

    fn read_field_2<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let str = iprot.read_string()?;
        self.str = Some(str);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("bin_method_args"))?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let bin = match self.bin {
            Some(ref bin) => bin,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "bin",
            thrift::protocol::TType::String,
            1,
        ))?;
        oprot.write_bytes(bin)?;
        oprot.write_field_end()
    }

    fn write_field_2<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let str = match self.str {
            Some(ref str) => str,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Str",
            thrift::protocol::TType::String,
            2,
        ))?;
        oprot.write_string(str)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooBinMethodResult {
    pub success: Option<Vec<u8>>,
    pub api: Option<actual_base_rust::ApiException>,
}

impl FFooBinMethodResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_bytes()?;
        self.success = Some(success);
        Ok(())
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut api = actual_base_rust::ApiException::default();
        api.read(iprot)?;
        self.api = Some(api);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "bin_method_result",
        ))?;
        self.write_field_0(oprot)?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::String,
            0,
        ))?;
        oprot.write_bytes(success)?;
        oprot.write_field_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let api = match self.api {
            Some(ref api) => api,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "api",
            thrift::protocol::TType::Struct,
            1,
        ))?;
        api.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooParamModifiersArgs {
    pub opt_num: Option<i32>,
    pub default_num: Option<i32>,
    pub req_num: i32,
}

impl FFooParamModifiersArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                Some(3) => self.read_field_3(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let opt_num = iprot.read_i32()?;
        self.opt_num = Some(opt_num);
        Ok(())
    }

    fn read_field_2<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let default_num = iprot.read_i32()?;
        self.default_num = Some(default_num);
        Ok(())
    }

    fn read_field_3<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let req_num = iprot.read_i32()?;
        self.req_num = req_num;
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "param_modifiers_args",
        ))?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        self.write_field_3(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let opt_num = match self.opt_num {
            Some(opt_num) => opt_num,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "opt_num",
            thrift::protocol::TType::I32,
            1,
        ))?;
        oprot.write_i32(opt_num)?;
        oprot.write_field_end()
    }

    fn write_field_2<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let default_num = match self.default_num {
            Some(default_num) => default_num,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "default_num",
            thrift::protocol::TType::I32,
            2,
        ))?;
        oprot.write_i32(default_num)?;
        oprot.write_field_end()
    }

    fn write_field_3<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let req_num = self.req_num;
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "req_num",
            thrift::protocol::TType::I32,
            3,
        ))?;
        oprot.write_i32(req_num)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooParamModifiersResult {
    pub success: Option<i64>,
}

impl FFooParamModifiersResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_i64()?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "param_modifiers_result",
        ))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::I64,
            0,
        ))?;
        oprot.write_i64(success)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooUnderlyingTypesTestArgs {
    pub list_type: Option<Vec<Id>>,
    pub set_type: Option<BTreeSet<Id>>,
}

impl FFooUnderlyingTypesTestArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                Some(2) => self.read_field_2(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let list_id = iprot.read_list_begin()?;
        let mut list_type = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let list_type_item = iprot.read_i64()?;
            list_type.push(list_type_item);
        }
        iprot.read_list_end()?;
        self.list_type = Some(list_type);
        Ok(())
    }

    fn read_field_2<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let set_id = iprot.read_set_begin()?;
        let mut set_type = BTreeSet::new();
        for _ in 0..set_id.size {
            let set_type_item = iprot.read_i64()?;
            set_type.insert(set_type_item);
        }
        iprot.read_set_end()?;
        self.set_type = Some(set_type);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "underlying_types_test_args",
        ))?;
        self.write_field_1(oprot)?;
        self.write_field_2(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let list_type = match self.list_type {
            Some(ref list_type) => list_type,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "list_type",
            thrift::protocol::TType::List,
            1,
        ))?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier::new(
            thrift::protocol::TType::I64,
            list_type.len() as i32,
        ))?;
        for list_type_item in list_type {
            oprot.write_i64(*list_type_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }

    fn write_field_2<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let set_type = match self.set_type {
            Some(ref set_type) => set_type,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "set_type",
            thrift::protocol::TType::Set,
            2,
        ))?;
        oprot.write_set_begin(&thrift::protocol::TSetIdentifier::new(
            thrift::protocol::TType::I64,
            set_type.len() as i32,
        ))?;
        for set_type_item in set_type {
            oprot.write_i64(*set_type_item)?;
        }
        oprot.write_set_end()?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooUnderlyingTypesTestResult {
    pub success: Option<Vec<Id>>,
}

impl FFooUnderlyingTypesTestResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let list_id = iprot.read_list_begin()?;
        let mut success = Vec::with_capacity(list_id.size as usize);
        for _ in 0..list_id.size {
            let success_item = iprot.read_i64()?;
            success.push(success_item);
        }
        iprot.read_list_end()?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "underlying_types_test_result",
        ))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::List,
            0,
        ))?;
        oprot.write_list_begin(&thrift::protocol::TListIdentifier::new(
            thrift::protocol::TType::I64,
            success.len() as i32,
        ))?;
        for success_item in success {
            oprot.write_i64(*success_item)?;
        }
        oprot.write_list_end()?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooGetThingArgs {}

impl FFooGetThingArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("getThing_args"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooGetThingResult {
    pub success: Option<valid_structs::Thing>,
}

impl FFooGetThingResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut success = valid_structs::Thing::default();
        success.read(iprot)?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("getThing_result"))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::Struct,
            0,
        ))?;
        success.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooGetMyIntArgs {}

impl FFooGetMyIntArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("getMyInt_args"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooGetMyIntResult {
    pub success: Option<valid_types::MyInt>,
}

impl FFooGetMyIntResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_i32()?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("getMyInt_result"))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::I32,
            0,
        ))?;
        oprot.write_i32(success)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooUseSubdirStructArgs {
    pub a: Option<subdir_include::A>,
}

impl FFooUseSubdirStructArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut a = subdir_include::A::default();
        a.read(iprot)?;
        self.a = Some(a);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "use_subdir_struct_args",
        ))?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let a = match self.a {
            Some(ref a) => a,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "a",
            thrift::protocol::TType::Struct,
            1,
        ))?;
        a.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooUseSubdirStructResult {
    pub success: Option<subdir_include::A>,
}

impl FFooUseSubdirStructResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let mut success = subdir_include::A::default();
        success.read(iprot)?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "use_subdir_struct_result",
        ))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::Struct,
            0,
        ))?;
        success.write(oprot)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooSayHelloWithArgs {
    pub new_message: Option<String>,
}

impl FFooSayHelloWithArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let new_message = iprot.read_string()?;
        self.new_message = Some(new_message);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "sayHelloWith_args",
        ))?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let new_message = match self.new_message {
            Some(ref new_message) => new_message,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "newMessage",
            thrift::protocol::TType::String,
            1,
        ))?;
        oprot.write_string(new_message)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooSayHelloWithResult {
    pub success: Option<String>,
}

impl FFooSayHelloWithResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_string()?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "sayHelloWith_result",
        ))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::String,
            0,
        ))?;
        oprot.write_string(success)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooWhatDoYouSayArgs {
    pub message_args: Option<String>,
}

impl FFooWhatDoYouSayArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let message_args = iprot.read_string()?;
        self.message_args = Some(message_args);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "whatDoYouSay_args",
        ))?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let message_args = match self.message_args {
            Some(ref message_args) => message_args,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "messageArgs",
            thrift::protocol::TType::String,
            1,
        ))?;
        oprot.write_string(message_args)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooWhatDoYouSayResult {
    pub success: Option<String>,
}

impl FFooWhatDoYouSayResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_string()?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new(
            "whatDoYouSay_result",
        ))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::String,
            0,
        ))?;
        oprot.write_string(success)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooSayAgainArgs {
    pub message_result: Option<String>,
}

impl FFooSayAgainArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(1) => self.read_field_1(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_1<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let message_result = iprot.read_string()?;
        self.message_result = Some(message_result);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("sayAgain_args"))?;
        self.write_field_1(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_1<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let message_result = match self.message_result {
            Some(ref message_result) => message_result,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "messageResult",
            thrift::protocol::TType::String,
            1,
        ))?;
        oprot.write_string(message_result)?;
        oprot.write_field_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooSayAgainResult {
    pub success: Option<String>,
}

impl FFooSayAgainResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                Some(0) => self.read_field_0(iprot)?,
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    fn read_field_0<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        let success = iprot.read_string()?;
        self.success = Some(success);
        Ok(())
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("sayAgain_result"))?;
        self.write_field_0(oprot)?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }

    fn write_field_0<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        let success = match self.success {
            Some(ref success) => success,
            None => return Ok(()),
        };
        oprot.write_field_begin(&thrift::protocol::TFieldIdentifier::new(
            "Success",
            thrift::protocol::TType::String,
            0,
        ))?;
        oprot.write_string(success)?;
        oprot.write_field_end()
    }
}

pub enum FFooMethod {
    Ping(FFooPingArgs),
    Blah(FFooBlahArgs),
    OneWay(FFooOneWayArgs),
    BinMethod(FFooBinMethodArgs),
    ParamModifiers(FFooParamModifiersArgs),
    UnderlyingTypesTest(FFooUnderlyingTypesTestArgs),
    GetThing(FFooGetThingArgs),
    GetMyInt(FFooGetMyIntArgs),
    UseSubdirStruct(FFooUseSubdirStructArgs),
    SayHelloWith(FFooSayHelloWithArgs),
    WhatDoYouSay(FFooWhatDoYouSayArgs),
    SayAgain(FFooSayAgainArgs),
}

impl FFooMethod {
    fn name(&self) -> &'static str {
        match *self {
            FFooMethod::Ping(_) => "Ping",
            FFooMethod::Blah(_) => "blah",
            FFooMethod::OneWay(_) => "oneWay",
            FFooMethod::BinMethod(_) => "bin_method",
            FFooMethod::ParamModifiers(_) => "param_modifiers",
            FFooMethod::UnderlyingTypesTest(_) => "underlying_types_test",
            FFooMethod::GetThing(_) => "getThing",
            FFooMethod::GetMyInt(_) => "getMyInt",
            FFooMethod::UseSubdirStruct(_) => "use_subdir_struct",
            FFooMethod::SayHelloWith(_) => "sayHelloWith",
            FFooMethod::WhatDoYouSay(_) => "whatDoYouSay",
            FFooMethod::SayAgain(_) => "sayAgain",
        }
    }
}

pub struct FFooRequest {
    ctx: FContext,
    method: FFooMethod,
}

impl FFooRequest {
    pub fn new(ctx: FContext, method: FFooMethod) -> FFooRequest {
        FFooRequest { ctx, method }
    }
}

impl frugal::service::Request for FFooRequest {
    fn context(&mut self) -> &mut FContext {
        &mut self.ctx
    }

    fn method_name(&self) -> &'static str {
        self.method.name()
    }
}

pub enum FFooResponse {
    Ping(FFooPingResult),
    Blah(FFooBlahResult),
    OneWay(FFooOneWayResult),
    BinMethod(FFooBinMethodResult),
    ParamModifiers(FFooParamModifiersResult),
    UnderlyingTypesTest(FFooUnderlyingTypesTestResult),
    GetThing(FFooGetThingResult),
    GetMyInt(FFooGetMyIntResult),
    UseSubdirStruct(FFooUseSubdirStructResult),
    SayHelloWith(FFooSayHelloWithResult),
    WhatDoYouSay(FFooWhatDoYouSayResult),
    SayAgain(FFooSayAgainResult),
}

pub struct FFooClient<S1, S2>
where
    S1: Service<
        Request = actual_base_rust::basefoo_service::FBaseFooRequest,
        Response = actual_base_rust::basefoo_service::FBaseFooResponse,
        Error = thrift::Error,
    >,
    S2: Service<Request = FFooRequest, Response = FFooResponse, Error = thrift::Error>,
{
    base_foo_client: actual_base_rust::basefoo_service::FBaseFooClient<S1>,
    service: S2,
}

impl<T>
    FFooClient<actual_base_rust::basefoo_service::FBaseFooClientService<T>, FFooClientService<T>>
where
    T: FTransport,
{
    pub fn new(
        provider: FServiceProvider<T>,
    ) -> FFooClient<actual_base_rust::basefoo_service::FBaseFooClientService<T>, FFooClientService<T>>
    {
        FFooClient {
            base_foo_client: actual_base_rust::basefoo_service::FBaseFooClient::new(
                provider.clone(),
            ),
            service: FFooClientService {
                transport: provider.transport,
                input_protocol_factory: provider.input_protocol_factory,
                output_protocol_factory: provider.output_protocol_factory,
            },
        }
    }
}

impl<S1, S2> actual_base_rust::basefoo_service::FBaseFoo for FFooClient<S1, S2>
where
    S1: Service<
        Request = actual_base_rust::basefoo_service::FBaseFooRequest,
        Response = actual_base_rust::basefoo_service::FBaseFooResponse,
        Error = thrift::Error,
    >,
    S2: Service<Request = FFooRequest, Response = FFooResponse, Error = thrift::Error>,
{
    fn base_ping(&mut self, ctx: &FContext) -> thrift::Result<()> {
        self.base_foo_client.base_ping(ctx)
    }
}

impl<S1, S2> FFoo for FFooClient<S1, S2>
where
    S1: Service<
        Request = actual_base_rust::basefoo_service::FBaseFooRequest,
        Response = actual_base_rust::basefoo_service::FBaseFooResponse,
        Error = thrift::Error,
    >,
    S2: Service<Request = FFooRequest, Response = FFooResponse, Error = thrift::Error>,
{
    fn ping(&mut self, ctx: &FContext) -> thrift::Result<()> {
        let args = FFooPingArgs::default();
        let request = FFooRequest::new(ctx.clone(), FFooMethod::Ping(args));
        match self.service.call(request).wait()? {
            FFooResponse::Ping(result) => Ok(()),
            _ => panic!("FFooClient::ping() received an incorrect response"),
        }
    }

    fn blah(
        &mut self,
        ctx: &FContext,
        num: Option<i32>,
        str: Option<String>,
        event: Option<Event>,
    ) -> thrift::Result<i64> {
        let args = FFooBlahArgs { num, str, event };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::Blah(args));
        match self.service.call(request).wait()? {
            FFooResponse::Blah(result) => {
                if let Some(awe) = result.awe {
                    return Err(thrift::Error::User(Box::new(awe)));
                };
                if let Some(api) = result.api {
                    return Err(thrift::Error::User(Box::new(api)));
                };
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"Blah\"",
                )))
            }
            _ => panic!("FFooClient::blah() received an incorrect response"),
        }
    }

    fn one_way(
        &mut self,
        ctx: &FContext,
        id: Option<Id>,
        req: Option<Request>,
    ) -> thrift::Result<()> {
        let args = FFooOneWayArgs { id, req };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::OneWay(args));
        match self.service.call(request).wait()? {
            FFooResponse::OneWay(result) => Ok(()),
            _ => panic!("FFooClient::one_way() received an incorrect response"),
        }
    }

    fn bin_method(
        &mut self,
        ctx: &FContext,
        bin: Option<Vec<u8>>,
        str: Option<String>,
    ) -> thrift::Result<Vec<u8>> {
        let args = FFooBinMethodArgs { bin, str };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::BinMethod(args));
        match self.service.call(request).wait()? {
            FFooResponse::BinMethod(result) => {
                if let Some(api) = result.api {
                    return Err(thrift::Error::User(Box::new(api)));
                };
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"BinMethod\"",
                )))
            }
            _ => panic!("FFooClient::bin_method() received an incorrect response"),
        }
    }

    fn param_modifiers(
        &mut self,
        ctx: &FContext,
        opt_num: Option<i32>,
        default_num: Option<i32>,
        req_num: i32,
    ) -> thrift::Result<i64> {
        let args = FFooParamModifiersArgs {
            opt_num,
            default_num,
            req_num,
        };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::ParamModifiers(args));
        match self.service.call(request).wait()? {
            FFooResponse::ParamModifiers(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"ParamModifiers\"",
                )))
            }
            _ => panic!("FFooClient::param_modifiers() received an incorrect response"),
        }
    }

    fn underlying_types_test(
        &mut self,
        ctx: &FContext,
        list_type: Option<Vec<Id>>,
        set_type: Option<BTreeSet<Id>>,
    ) -> thrift::Result<Vec<Id>> {
        let args = FFooUnderlyingTypesTestArgs {
            list_type,
            set_type,
        };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::UnderlyingTypesTest(args));
        match self.service.call(request).wait()? {
            FFooResponse::UnderlyingTypesTest(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"UnderlyingTypesTest\"",
                )))
            }
            _ => panic!("FFooClient::underlying_types_test() received an incorrect response"),
        }
    }

    fn get_thing(&mut self, ctx: &FContext) -> thrift::Result<valid_structs::Thing> {
        let args = FFooGetThingArgs::default();
        let request = FFooRequest::new(ctx.clone(), FFooMethod::GetThing(args));
        match self.service.call(request).wait()? {
            FFooResponse::GetThing(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"GetThing\"",
                )))
            }
            _ => panic!("FFooClient::get_thing() received an incorrect response"),
        }
    }

    fn get_my_int(&mut self, ctx: &FContext) -> thrift::Result<valid_types::MyInt> {
        let args = FFooGetMyIntArgs::default();
        let request = FFooRequest::new(ctx.clone(), FFooMethod::GetMyInt(args));
        match self.service.call(request).wait()? {
            FFooResponse::GetMyInt(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"GetMyInt\"",
                )))
            }
            _ => panic!("FFooClient::get_my_int() received an incorrect response"),
        }
    }

    fn use_subdir_struct(
        &mut self,
        ctx: &FContext,
        a: Option<subdir_include::A>,
    ) -> thrift::Result<subdir_include::A> {
        let args = FFooUseSubdirStructArgs { a };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::UseSubdirStruct(args));
        match self.service.call(request).wait()? {
            FFooResponse::UseSubdirStruct(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"UseSubdirStruct\"",
                )))
            }
            _ => panic!("FFooClient::use_subdir_struct() received an incorrect response"),
        }
    }

    fn say_hello_with(
        &mut self,
        ctx: &FContext,
        new_message: Option<String>,
    ) -> thrift::Result<String> {
        let args = FFooSayHelloWithArgs { new_message };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::SayHelloWith(args));
        match self.service.call(request).wait()? {
            FFooResponse::SayHelloWith(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"SayHelloWith\"",
                )))
            }
            _ => panic!("FFooClient::say_hello_with() received an incorrect response"),
        }
    }

    fn what_do_you_say(
        &mut self,
        ctx: &FContext,
        message_args: Option<String>,
    ) -> thrift::Result<String> {
        let args = FFooWhatDoYouSayArgs { message_args };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::WhatDoYouSay(args));
        match self.service.call(request).wait()? {
            FFooResponse::WhatDoYouSay(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"WhatDoYouSay\"",
                )))
            }
            _ => panic!("FFooClient::what_do_you_say() received an incorrect response"),
        }
    }

    fn say_again(
        &mut self,
        ctx: &FContext,
        message_result: Option<String>,
    ) -> thrift::Result<String> {
        let args = FFooSayAgainArgs { message_result };
        let request = FFooRequest::new(ctx.clone(), FFooMethod::SayAgain(args));
        match self.service.call(request).wait()? {
            FFooResponse::SayAgain(result) => {
                if let Some(success) = result.success {
                    return Ok(success);
                };
                Err(thrift::Error::Application(thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::MissingResult,
                    "result was not returned for \"SayAgain\"",
                )))
            }
            _ => panic!("FFooClient::say_again() received an incorrect response"),
        }
    }
}

pub struct FFooClientService<T>
where
    T: FTransport,
{
    transport: T,
    input_protocol_factory: FInputProtocolFactory,
    output_protocol_factory: FOutputProtocolFactory,
}

impl<T> FFooClientService<T>
where
    T: FTransport,
{
    fn call_delegate(&mut self, req: FFooRequest) -> Result<FFooResponse, thrift::Error> {
        enum ResultSignifier {
            Ping,
            Blah,
            OneWay,
            BinMethod,
            ParamModifiers,
            UnderlyingTypesTest,
            GetThing,
            GetMyInt,
            UseSubdirStruct,
            SayHelloWith,
            WhatDoYouSay,
            SayAgain,
        };
        let FFooRequest { mut ctx, method } = req;
        let method_name = method.name();
        let mut buffer = FMemoryOutputBuffer::new(0);
        let signifier = {
            let mut oprot = self.output_protocol_factory.get_protocol(&mut buffer);
            oprot.write_request_header(&ctx)?;
            let mut oproxy = oprot.t_protocol_proxy();
            let signifier = match method {
                FFooMethod::Ping(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "Ping",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooPingArgs {};
                    args.write(&mut oproxy)?;
                    ResultSignifier::Ping
                }
                FFooMethod::Blah(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "blah",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooBlahArgs {
                        num: args.num,
                        str: args.str,
                        event: args.event,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::Blah
                }
                FFooMethod::OneWay(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "oneWay",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooOneWayArgs {
                        id: args.id,
                        req: args.req,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::OneWay
                }
                FFooMethod::BinMethod(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "bin_method",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooBinMethodArgs {
                        bin: args.bin,
                        str: args.str,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::BinMethod
                }
                FFooMethod::ParamModifiers(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "param_modifiers",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooParamModifiersArgs {
                        opt_num: args.opt_num,
                        default_num: args.default_num,
                        req_num: args.req_num,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::ParamModifiers
                }
                FFooMethod::UnderlyingTypesTest(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "underlying_types_test",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooUnderlyingTypesTestArgs {
                        list_type: args.list_type,
                        set_type: args.set_type,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::UnderlyingTypesTest
                }
                FFooMethod::GetThing(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "getThing",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooGetThingArgs {};
                    args.write(&mut oproxy)?;
                    ResultSignifier::GetThing
                }
                FFooMethod::GetMyInt(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "getMyInt",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooGetMyIntArgs {};
                    args.write(&mut oproxy)?;
                    ResultSignifier::GetMyInt
                }
                FFooMethod::UseSubdirStruct(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "use_subdir_struct",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooUseSubdirStructArgs { a: args.a };
                    args.write(&mut oproxy)?;
                    ResultSignifier::UseSubdirStruct
                }
                FFooMethod::SayHelloWith(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "sayHelloWith",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooSayHelloWithArgs {
                        new_message: args.new_message,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::SayHelloWith
                }
                FFooMethod::WhatDoYouSay(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "whatDoYouSay",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooWhatDoYouSayArgs {
                        message_args: args.message_args,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::WhatDoYouSay
                }
                FFooMethod::SayAgain(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "sayAgain",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooSayAgainArgs {
                        message_result: args.message_result,
                    };
                    args.write(&mut oproxy)?;
                    ResultSignifier::SayAgain
                }
            };
            oproxy.write_message_end()?;
            oproxy.flush()?;
            signifier
        };
        let mut result_transport = self.transport.request(&ctx, buffer.bytes())?;
        {
            let mut iprot = self
                .input_protocol_factory
                .get_protocol(&mut result_transport);
            iprot.read_response_header(&mut ctx)?;
            let mut iproxy = iprot.t_protocol_proxy();
            let msg_id = iproxy.read_message_begin()?;
            if msg_id.name != method_name {
                return Err(thrift::new_application_error(
                    thrift::ApplicationErrorKind::WrongMethodName,
                    format!("{} failed: wrong method name", method_name),
                ));
            }
            match msg_id.message_type {
                thrift::protocol::TMessageType::Exception => {
                    let err = thrift::Error::Application(
                        thrift::Error::read_application_error_from_in_protocol(&mut iproxy)?,
                    );
                    iproxy.read_message_end()?;
                    if frugal::errors::is_too_large_error(&err) {
                        Err(thrift::new_transport_error(
                            thrift::TransportErrorKind::SizeLimit,
                            err.to_string(),
                        ))
                    } else {
                        Err(err)
                    }
                }
                thrift::protocol::TMessageType::Reply => match signifier {
                    ResultSignifier::Ping => {
                        let mut result = FFooPingResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::Ping(result))
                    }
                    ResultSignifier::Blah => {
                        let mut result = FFooBlahResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::Blah(result))
                    }
                    ResultSignifier::OneWay => {
                        let mut result = FFooOneWayResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::OneWay(result))
                    }
                    ResultSignifier::BinMethod => {
                        let mut result = FFooBinMethodResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::BinMethod(result))
                    }
                    ResultSignifier::ParamModifiers => {
                        let mut result = FFooParamModifiersResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::ParamModifiers(result))
                    }
                    ResultSignifier::UnderlyingTypesTest => {
                        let mut result = FFooUnderlyingTypesTestResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::UnderlyingTypesTest(result))
                    }
                    ResultSignifier::GetThing => {
                        let mut result = FFooGetThingResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::GetThing(result))
                    }
                    ResultSignifier::GetMyInt => {
                        let mut result = FFooGetMyIntResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::GetMyInt(result))
                    }
                    ResultSignifier::UseSubdirStruct => {
                        let mut result = FFooUseSubdirStructResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::UseSubdirStruct(result))
                    }
                    ResultSignifier::SayHelloWith => {
                        let mut result = FFooSayHelloWithResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::SayHelloWith(result))
                    }
                    ResultSignifier::WhatDoYouSay => {
                        let mut result = FFooWhatDoYouSayResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::WhatDoYouSay(result))
                    }
                    ResultSignifier::SayAgain => {
                        let mut result = FFooSayAgainResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooResponse::SayAgain(result))
                    }
                },
                _ => Err(thrift::new_application_error(
                    thrift::ApplicationErrorKind::InvalidMessageType,
                    format!("{} failed: invalid message type", method_name),
                )),
            }
        }
    }
}

impl<T> Service for FFooClientService<T>
where
    T: FTransport,
{
    type Request = FFooRequest;
    type Response = FFooResponse;
    type Error = thrift::Error;
    type Future = FutureResult<Self::Response, Self::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(&mut self, req: Self::Request) -> Self::Future {
        self.call_delegate(req).into()
    }
}

#[derive(Clone)]
pub struct FFooProcessor<S>
where
    S: Service<Request = FFooRequest, Response = FFooResponse, Error = thrift::Error>,
{
    service: S,
}

pub struct FFooProcessorBuilder<F, M>
where
    F: FFoo,
{
    handler: F,
    middleware: M,
}

impl<F> FFooProcessorBuilder<F, middleware::Identity>
where
    F: FFoo,
{
    pub fn new(handler: F) -> Self {
        FFooProcessorBuilder {
            handler,
            middleware: middleware::Identity::new(),
        }
    }
}

impl<F, M> FFooProcessorBuilder<F, M>
where
    F: FFoo + Clone,
{
    pub fn middleware<U>(self, middleware: U) -> FFooProcessorBuilder<F, <M as Chain<U>>::Output>
    where
        M: Chain<U>,
    {
        FFooProcessorBuilder {
            handler: self.handler,
            middleware: self.middleware.chain(middleware),
        }
    }

    pub fn build(self) -> FFooProcessor<M::Service>
    where
        M: Middleware<
            FFooProcessorService<F>,
            Request = FFooRequest,
            Response = FFooResponse,
            Error = thrift::Error,
        >,
    {
        FFooProcessor {
            service: self.middleware.wrap(FFooProcessorService(self.handler)),
        }
    }
}

#[derive(Clone)]
pub struct FFooProcessorService<F: FFoo + Clone>(F);

impl<F> Service for FFooProcessorService<F>
where
    F: FFoo + Clone,
{
    type Request = FFooRequest;
    type Response = FFooResponse;
    type Error = thrift::Error;
    type Future = FutureResult<Self::Response, Self::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(&mut self, req: FFooRequest) -> FutureResult<FFooResponse, thrift::Error> {
        let result = match req.method {
            FFooMethod::Ping(args) => self
                .0
                .ping(&req.ctx)
                .map(|res| FFooResponse::Ping(FFooPingResult {})),
            FFooMethod::Blah(args) => match self.0.blah(&req.ctx, args.num, args.str, args.event) {
                Ok(res) => Ok(FFooResponse::Blah(FFooBlahResult {
                    success: Some(res),
                    awe: None,
                    api: None,
                })),
                Err(err) => match err {
                    thrift::Error::User(user_err) => user_err
                        .downcast::<AwesomeException>()
                        .map(|awe| {
                            FFooResponse::Blah(FFooBlahResult {
                                success: None,
                                awe: Some(*awe),
                                api: None,
                            })
                        })
                        .or_else(|not_awe| {
                            not_awe
                                .downcast::<actual_base_rust::ApiException>()
                                .map(|api| {
                                    FFooResponse::Blah(FFooBlahResult {
                                        success: None,
                                        awe: None,
                                        api: Some(*api),
                                    })
                                })
                        })
                        .map_err(|err| thrift::Error::User(err)),
                    _ => Err(err),
                },
            },
            FFooMethod::OneWay(args) => self
                .0
                .one_way(&req.ctx, args.id, args.req)
                .map(|res| FFooResponse::OneWay(FFooOneWayResult {})),
            FFooMethod::BinMethod(args) => match self.0.bin_method(&req.ctx, args.bin, args.str) {
                Ok(res) => Ok(FFooResponse::BinMethod(FFooBinMethodResult {
                    success: Some(res),
                    api: None,
                })),
                Err(err) => match err {
                    thrift::Error::User(user_err) => user_err
                        .downcast::<actual_base_rust::ApiException>()
                        .map(|api| {
                            FFooResponse::BinMethod(FFooBinMethodResult {
                                success: None,
                                api: Some(*api),
                            })
                        })
                        .map_err(|err| thrift::Error::User(err)),
                    _ => Err(err),
                },
            },
            FFooMethod::ParamModifiers(args) => self
                .0
                .param_modifiers(&req.ctx, args.opt_num, args.default_num, args.req_num)
                .map(|res| {
                    FFooResponse::ParamModifiers(FFooParamModifiersResult { success: Some(res) })
                }),
            FFooMethod::UnderlyingTypesTest(args) => self
                .0
                .underlying_types_test(&req.ctx, args.list_type, args.set_type)
                .map(|res| {
                    FFooResponse::UnderlyingTypesTest(FFooUnderlyingTypesTestResult {
                        success: Some(res),
                    })
                }),
            FFooMethod::GetThing(args) => self
                .0
                .get_thing(&req.ctx)
                .map(|res| FFooResponse::GetThing(FFooGetThingResult { success: Some(res) })),
            FFooMethod::GetMyInt(args) => self
                .0
                .get_my_int(&req.ctx)
                .map(|res| FFooResponse::GetMyInt(FFooGetMyIntResult { success: Some(res) })),
            FFooMethod::UseSubdirStruct(args) => {
                self.0.use_subdir_struct(&req.ctx, args.a).map(|res| {
                    FFooResponse::UseSubdirStruct(FFooUseSubdirStructResult { success: Some(res) })
                })
            }
            FFooMethod::SayHelloWith(args) => self
                .0
                .say_hello_with(&req.ctx, args.new_message)
                .map(|res| {
                    FFooResponse::SayHelloWith(FFooSayHelloWithResult { success: Some(res) })
                }),
            FFooMethod::WhatDoYouSay(args) => self
                .0
                .what_do_you_say(&req.ctx, args.message_args)
                .map(|res| {
                    FFooResponse::WhatDoYouSay(FFooWhatDoYouSayResult { success: Some(res) })
                }),
            FFooMethod::SayAgain(args) => self
                .0
                .say_again(&req.ctx, args.message_result)
                .map(|res| FFooResponse::SayAgain(FFooSayAgainResult { success: Some(res) })),
        };
        future::result(result)
    }
}

impl<S> FProcessor for FFooProcessor<S>
where
    S: Service<Request = FFooRequest, Response = FFooResponse, Error = thrift::Error>
        + Clone
        + Send
        + 'static,
{
    fn process<R, W>(
        &mut self,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let ctx = iprot.read_request_header()?;
        let name = {
            let mut iproxy = iprot.t_protocol_proxy();
            iproxy.read_message_begin().map(|tmid| tmid.name)?
        };

        match &*name {
            "Ping" => self.ping(&ctx, iprot, oprot),
            "blah" => self.blah(&ctx, iprot, oprot),
            "oneWay" => self.one_way(&ctx, iprot, oprot),
            "bin_method" => self.bin_method(&ctx, iprot, oprot),
            "param_modifiers" => self.param_modifiers(&ctx, iprot, oprot),
            "underlying_types_test" => self.underlying_types_test(&ctx, iprot, oprot),
            "getThing" => self.get_thing(&ctx, iprot, oprot),
            "getMyInt" => self.get_my_int(&ctx, iprot, oprot),
            "use_subdir_struct" => self.use_subdir_struct(&ctx, iprot, oprot),
            "sayHelloWith" => self.say_hello_with(&ctx, iprot, oprot),
            "whatDoYouSay" => self.what_do_you_say(&ctx, iprot, oprot),
            "sayAgain" => self.say_again(&ctx, iprot, oprot),
            _ => {
                error!(
                    "frugal: client invoked unknown function {} on request with correlation id {}",
                    &name,
                    ctx.correlation_id()
                );
                let mut iproxy = iprot.t_protocol_proxy();
                iproxy.skip(thrift::protocol::TType::Struct)?;
                iproxy.read_message_end()?;

                oprot.write_response_header(&ctx)?;
                let mut oproxy = oprot.t_protocol_proxy();
                oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                    &name as &str,
                    thrift::protocol::TMessageType::Exception,
                    0,
                ))?;
                let ex = thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::UnknownMethod,
                    format!("Unknown function {}", &name),
                );
                thrift::Error::write_application_error_to_out_protocol(&ex, &mut oproxy)?;
                oproxy.write_message_end()?;
                oproxy.flush()
            }
        }
    }
}

impl<S> FFooProcessor<S>
where
    S: Service<Request = FFooRequest, Response = FFooResponse, Error = thrift::Error>,
{
    fn ping<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooPingArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::Ping(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::Ping(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "Ping",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "Ping",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn blah<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooBlahArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::Blah(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::Blah(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "blah",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "blah",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn one_way<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooOneWayArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::OneWay(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::OneWay(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "oneWay",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "oneWay",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn bin_method<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooBinMethodArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::BinMethod(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::BinMethod(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "bin_method",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "bin_method",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn param_modifiers<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooParamModifiersArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::ParamModifiers(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::ParamModifiers(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "param_modifiers",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "param_modifiers",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn underlying_types_test<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooUnderlyingTypesTestArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::UnderlyingTypesTest(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::UnderlyingTypesTest(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "underlying_types_test",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "underlying_types_test",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn get_thing<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooGetThingArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::GetThing(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::GetThing(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "getThing",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "getThing",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn get_my_int<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooGetMyIntArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::GetMyInt(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::GetMyInt(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "getMyInt",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "getMyInt",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn use_subdir_struct<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooUseSubdirStructArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::UseSubdirStruct(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::UseSubdirStruct(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "use_subdir_struct",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "use_subdir_struct",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn say_hello_with<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooSayHelloWithArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::SayHelloWith(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::SayHelloWith(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "sayHelloWith",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "sayHelloWith",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn what_do_you_say<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooWhatDoYouSayArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::WhatDoYouSay(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::WhatDoYouSay(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "whatDoYouSay",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "whatDoYouSay",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn say_again<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooSayAgainArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooRequest {
            ctx: ctx.clone(),
            method: FFooMethod::SayAgain(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooResponse::SayAgain(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "sayAgain",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "sayAgain",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }
}
