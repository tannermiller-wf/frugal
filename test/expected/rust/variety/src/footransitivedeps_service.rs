// Autogenerated by Frugal Compiler (3.3.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_variables)]

use std::collections::BTreeMap;
use std::error::Error;

use futures::future::{self, FutureResult};
use futures::{Async, Future, Poll};
use thrift;
use thrift::protocol::{TInputProtocol, TOutputProtocol};
use tower_service::Service;
use tower_web::middleware::{self, Middleware};
use tower_web::util::Chain;

use frugal::buffer::FMemoryOutputBuffer;
use frugal::context::{FContext, OP_ID_HEADER};
use frugal::errors;
use frugal::processor::FProcessor;
use frugal::protocol::{
    FInputProtocol, FInputProtocolFactory, FOutputProtocol, FOutputProtocolFactory,
};
use frugal::provider::FServiceProvider;
use frugal::transport::FTransport;

use super::*;
use actual_base_rust;
use intermediate_include;
use subdir_include;
use valid_structs;
use valid_types;

pub trait FFooTransitiveDeps:
    intermediate_include::intermediatefoo_service::FIntermediateFoo
{
    fn ping(&mut self, ctx: &FContext) -> thrift::Result<()>;
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooTransitiveDepsPingArgs {}

impl FFooTransitiveDepsPingArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("ping_args"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FFooTransitiveDepsPingResult {}

impl FFooTransitiveDepsPingResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("ping_result"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

pub enum FFooTransitiveDepsMethod {
    Ping(FFooTransitiveDepsPingArgs),
    IntermediateFooIntermeidateFoo(::intermediatefoo_service::FIntermediateFooIntermeidateFooArgs),
}

impl FFooTransitiveDepsMethod {
    fn name(&self) -> &'static str {
        match *self {
            FFooTransitiveDepsMethod::Ping(_) => "ping",
            FFooTransitiveDepsMethod::IntermediateFooIntermeidateFoo(_) => "IntermeidateFoo",
        }
    }
}

pub struct FFooTransitiveDepsRequest {
    ctx: FContext,
    method: FFooTransitiveDepsMethod,
}

impl FFooTransitiveDepsRequest {
    pub fn new(ctx: FContext, method: FFooTransitiveDepsMethod) -> FFooTransitiveDepsRequest {
        FFooTransitiveDepsRequest { ctx, method }
    }
}

impl frugal::service::Request for FFooTransitiveDepsRequest {
    fn context(&mut self) -> &mut FContext {
        &mut self.ctx
    }

    fn method_name(&self) -> &'static str {
        self.method.name()
    }
}

pub enum FFooTransitiveDepsResponse {
    Ping(FFooTransitiveDepsPingResult),
    IntermediateFooIntermeidateFoo(
        ::intermediatefoo_service::FIntermediateFooIntermeidateFooResult,
    ),
}

pub struct FFooTransitiveDepsClient<S0, S1>
where
    S0: Service<
        Request = intermediate_include::intermediatefoo_service::FIntermediateFooRequest,
        Response = intermediate_include::intermediatefoo_service::FIntermediateFooResponse,
        Error = thrift::Error,
    >,
    S1: Service<
        Request = FFooTransitiveDepsRequest,
        Response = FFooTransitiveDepsResponse,
        Error = thrift::Error,
    >,
{
    intermediate_foo_client:
        intermediate_include::intermediatefoo_service::FIntermediateFooClient<S0>,
    service: S1,
}

impl<T>
    FFooTransitiveDepsClient<
        intermediate_include::intermediatefoo_service::FIntermediateFooClientService<T>,
        FFooTransitiveDepsClientService<T>,
    >
where
    T: FTransport,
{
    pub fn new(
        provider: FServiceProvider<T>,
    ) -> FFooTransitiveDepsClient<
        intermediate_include::intermediatefoo_service::FIntermediateFooClientService<T>,
        FFooTransitiveDepsClientService<T>,
    > {
        FFooTransitiveDepsClient {
            intermediate_foo_client:
                intermediate_include::intermediatefoo_service::FIntermediateFooClient::new(
                    provider.clone(),
                ),
            service: FFooTransitiveDepsClientService {
                transport: provider.transport,
                input_protocol_factory: provider.input_protocol_factory,
                output_protocol_factory: provider.output_protocol_factory,
            },
        }
    }
}

impl<S0, S1> intermediate_include::intermediatefoo_service::FIntermediateFoo
    for FFooTransitiveDepsClient<S0, S1>
where
    S0: Service<
        Request = intermediate_include::intermediatefoo_service::FIntermediateFooRequest,
        Response = intermediate_include::intermediatefoo_service::FIntermediateFooResponse,
        Error = thrift::Error,
    >,
    S1: Service<
        Request = FFooTransitiveDepsRequest,
        Response = FFooTransitiveDepsResponse,
        Error = thrift::Error,
    >,
{
    fn intermeidate_foo(&mut self, ctx: &FContext) -> thrift::Result<()> {
        self.intermediate_foo_client.intermeidate_foo(ctx)
    }
}

impl<S0, S1> FFooTransitiveDeps for FFooTransitiveDepsClient<S0, S1>
where
    S0: Service<
        Request = intermediate_include::intermediatefoo_service::FIntermediateFooRequest,
        Response = intermediate_include::intermediatefoo_service::FIntermediateFooResponse,
        Error = thrift::Error,
    >,
    S1: Service<
        Request = FFooTransitiveDepsRequest,
        Response = FFooTransitiveDepsResponse,
        Error = thrift::Error,
    >,
{
    fn ping(&mut self, ctx: &FContext) -> thrift::Result<()> {
        let args = FFooTransitiveDepsPingArgs {};
        let request =
            FFooTransitiveDepsRequest::new(ctx.clone(), FFooTransitiveDepsMethod::Ping(args));
        match self.service.call(request).wait()? {
            FFooTransitiveDepsResponse::Ping(result) => Ok(()),
        }
    }
}

pub struct FFooTransitiveDepsClientService<T>
where
    T: FTransport,
{
    transport: T,
    input_protocol_factory: FInputProtocolFactory,
    output_protocol_factory: FOutputProtocolFactory,
}

impl<T> FFooTransitiveDepsClientService<T>
where
    T: FTransport,
{
    fn call_delegate(
        &mut self,
        req: FFooTransitiveDepsRequest,
    ) -> Result<FFooTransitiveDepsResponse, thrift::Error> {
        enum ResultSignifier {
            Ping,
            IntermediateFooIntermeidateFoo,
        };
        let FFooTransitiveDepsRequest { mut ctx, method } = req;
        let method_name = method.name();
        let mut buffer = FMemoryOutputBuffer::new(0);
        let signifier = {
            let mut oprot = self.output_protocol_factory.get_protocol(&mut buffer);
            oprot.write_request_header(&ctx)?;
            let mut oproxy = oprot.t_protocol_proxy();
            let signifier = match method {
                FFooTransitiveDepsMethod::Ping(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "ping",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = FFooTransitiveDepsPingArgs {};
                    args.write(&mut oproxy)?;
                    ResultSignifier::Ping
                }
                FFooTransitiveDepsMethod::IntermediateFooIntermeidateFoo(args) => {
                    oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                        "IntermeidateFoo",
                        thrift::protocol::TMessageType::Call,
                        0,
                    ))?;
                    let args = ::intermediatefoo_service::FIntermediateFooIntermeidateFooArgs {};
                    args.write(&mut oproxy)?;
                    ResultSignifier::IntermediateFooIntermeidateFoo
                }
            };
            oproxy.write_message_end()?;
            oproxy.flush()?;
            signifier
        };
        let mut result_transport = self.transport.request(&ctx, buffer.bytes())?;
        {
            let mut iprot = self
                .input_protocol_factory
                .get_protocol(&mut result_transport);
            iprot.read_response_header(&mut ctx)?;
            let mut iproxy = iprot.t_protocol_proxy();
            let msg_id = iproxy.read_message_begin()?;
            if msg_id.name != method_name {
                return Err(thrift::new_application_error(
                    thrift::ApplicationErrorKind::WrongMethodName,
                    format!("{} failed: wrong method name", method_name),
                ));
            }
            match msg_id.message_type {
                thrift::protocol::TMessageType::Exception => {
                    let err = thrift::Error::Application(
                        thrift::Error::read_application_error_from_in_protocol(&mut iproxy)?,
                    );
                    iproxy.read_message_end()?;
                    if frugal::errors::is_too_large_error(&err) {
                        Err(thrift::new_transport_error(
                            thrift::TransportErrorKind::SizeLimit,
                            err.to_string(),
                        ))
                    } else {
                        Err(err)
                    }
                }
                thrift::protocol::TMessageType::Reply => match signifier {
                    ResultSignifier::Ping => {
                        let mut result = FFooTransitiveDepsPingResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooTransitiveDepsResponse::Ping(result))
                    }
                    ResultSignifier::IntermediateFooIntermeidateFoo => {
                        let mut result = ::intermediatefoo_service::FIntermediateFooIntermeidateFooResult::default();
                        result.read(&mut iproxy)?;
                        iproxy.read_message_end()?;
                        Ok(FFooTransitiveDepsResponse::IntermediateFooIntermeidateFoo(
                            result,
                        ))
                    }
                },
                _ => Err(thrift::new_application_error(
                    thrift::ApplicationErrorKind::InvalidMessageType,
                    format!("{} failed: invalid message type", method_name),
                )),
            }
        }
    }
}

impl<T> Service for FFooTransitiveDepsClientService<T>
where
    T: FTransport,
{
    type Request = FFooTransitiveDepsRequest;
    type Response = FFooTransitiveDepsResponse;
    type Error = thrift::Error;
    type Future = FutureResult<Self::Response, Self::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(&mut self, req: Self::Request) -> Self::Future {
        self.call_delegate(req).into()
    }
}

#[derive(Clone)]
pub struct FFooTransitiveDepsProcessor<S>
where
    S: Service<
        Request = FFooTransitiveDepsRequest,
        Response = FFooTransitiveDepsResponse,
        Error = thrift::Error,
    >,
{
    service: S,
}

pub struct FFooTransitiveDepsProcessorBuilder<F, M>
where
    F: FFooTransitiveDeps,
{
    handler: F,
    middleware: M,
}

impl<F> FFooTransitiveDepsProcessorBuilder<F, middleware::Identity>
where
    F: FFooTransitiveDeps,
{
    pub fn new(handler: F) -> Self {
        FFooTransitiveDepsProcessorBuilder {
            handler,
            middleware: middleware::Identity::new(),
        }
    }
}

impl<F, M> FFooTransitiveDepsProcessorBuilder<F, M>
where
    F: FFooTransitiveDeps + Clone,
{
    pub fn middleware<U>(
        self,
        middleware: U,
    ) -> FFooTransitiveDepsProcessorBuilder<F, <M as Chain<U>>::Output>
    where
        M: Chain<U>,
    {
        FFooTransitiveDepsProcessorBuilder {
            handler: self.handler,
            middleware: self.middleware.chain(middleware),
        }
    }

    pub fn build(self) -> FFooTransitiveDepsProcessor<M::Service>
    where
        M: Middleware<
            FFooTransitiveDepsProcessorService<F>,
            Request = FFooTransitiveDepsRequest,
            Response = FFooTransitiveDepsResponse,
            Error = thrift::Error,
        >,
    {
        FFooTransitiveDepsProcessor {
            service: self
                .middleware
                .wrap(FFooTransitiveDepsProcessorService(self.handler)),
        }
    }
}

#[derive(Clone)]
pub struct FFooTransitiveDepsProcessorService<F: FFooTransitiveDeps + Clone>(F);

impl<F> Service for FFooTransitiveDepsProcessorService<F>
where
    F: FFooTransitiveDeps + Clone,
{
    type Request = FFooTransitiveDepsRequest;
    type Response = FFooTransitiveDepsResponse;
    type Error = thrift::Error;
    type Future = FutureResult<Self::Response, Self::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(
        &mut self,
        req: FFooTransitiveDepsRequest,
    ) -> FutureResult<FFooTransitiveDepsResponse, thrift::Error> {
        let result = match req.method {
            FFooTransitiveDepsMethod::Ping(args) => self
                .0
                .ping(&req.ctx)
                .map(|res| FFooTransitiveDepsResponse::Ping(FFooTransitiveDepsPingResult {})),
            FFooTransitiveDepsMethod::IntermediateFooIntermeidateFoo(args) => {
                self.0.intermeidate_foo(&req.ctx).map(|res| {
                    FFooTransitiveDepsResponse::IntermediateFooIntermeidateFoo(
                        ::intermediatefoo_service::FIntermediateFooIntermeidateFooResult {},
                    )
                })
            }
        };
        future::result(result)
    }
}

impl<S> FProcessor for FFooTransitiveDepsProcessor<S>
where
    S: Service<
            Request = FFooTransitiveDepsRequest,
            Response = FFooTransitiveDepsResponse,
            Error = thrift::Error,
        > + Clone
        + Send
        + 'static,
{
    fn process<R, W>(
        &mut self,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let ctx = iprot.read_request_header()?;
        let name = {
            let mut iproxy = iprot.t_protocol_proxy();
            iproxy.read_message_begin().map(|tmid| tmid.name)?
        };

        match &*name {
            "ping" => self.ping(&ctx, iprot, oprot),
            "IntermeidateFoo" => self.intermediatefoo_intermeidate_foo(&ctx, iprot, oprot),
            _ => {
                error!(
                    "frugal: client invoked unknown function {} on request with correlation id {}",
                    &name,
                    ctx.correlation_id()
                );
                let mut iproxy = iprot.t_protocol_proxy();
                iproxy.skip(thrift::protocol::TType::Struct)?;
                iproxy.read_message_end()?;

                oprot.write_response_header(&ctx)?;
                let mut oproxy = oprot.t_protocol_proxy();
                oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                    &name as &str,
                    thrift::protocol::TMessageType::Exception,
                    0,
                ))?;
                let ex = thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::UnknownMethod,
                    format!("Unknown function {}", &name),
                );
                thrift::Error::write_application_error_to_out_protocol(&ex, &mut oproxy)?;
                oproxy.write_message_end()?;
                oproxy.flush()
            }
        }
    }
}

impl<S> FFooTransitiveDepsProcessor<S>
where
    S: Service<
        Request = FFooTransitiveDepsRequest,
        Response = FFooTransitiveDepsResponse,
        Error = thrift::Error,
    >,
{
    fn ping<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = FFooTransitiveDepsPingArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooTransitiveDepsRequest {
            ctx: ctx.clone(),
            method: FFooTransitiveDepsMethod::Ping(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooTransitiveDepsResponse::Ping(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "ping",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "ping",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }

    fn intermediatefoo_intermeidate_foo<R, W>(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        W: thrift::transport::TWriteTransport,
    {
        let mut args = ::intermediatefoo_service::FIntermediateFooIntermeidateFooArgs::default();
        let mut iproxy = iprot.t_protocol_proxy();
        args.read(&mut iproxy)?;
        iproxy.read_message_end()?;
        let req = FFooTransitiveDepsRequest {
            ctx: ctx.clone(),
            method: FFooTransitiveDepsMethod::IntermediateFooIntermeidateFoo(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(FFooTransitiveDepsResponse::IntermediateFooIntermeidateFoo(result)) => oprot
                .write_response_header(&ctx)
                .and_then(|()| {
                    oprot.t_protocol_proxy().write_message_begin(
                        &thrift::protocol::TMessageIdentifier::new(
                            "IntermeidateFoo",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ),
                    )
                })
                .and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
                .and_then(|()| oprot.t_protocol_proxy().write_message_end())
                .and_then(|()| oprot.t_protocol_proxy().flush())
                .or_else(|err| {
                    if errors::is_too_large_error(&err) {
                        errors::write_application_error(
                            "IntermeidateFoo",
                            &ctx,
                            &thrift::ApplicationError::new(
                                thrift::ApplicationErrorKind::Unknown,
                                errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                            ),
                            oprot,
                        )
                    } else {
                        Err(err)
                    }
                }),
            Ok(_) => unreachable!(),
        }
    }
}
