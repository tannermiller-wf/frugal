// Autogenerated by Frugal Compiler (2.23.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_variables)]

use std::collections::BTreeMap;
use std::error::Error;

use futures::future::{self, FutureResult};
use futures::{Async, Future, Poll};
use thrift;
use thrift::protocol::{TInputProtocol, TOutputProtocol};
use tower_service::Service;
use tower_web::middleware::{self, Middleware};
use tower_web::util::Chain;

use frugal::context::FContext;
use frugal::errors;
use frugal::processor::FProcessor;
use frugal::protocol::{
    FInputProtocol, FInputProtocolFactory, FOutputProtocol, FOutputProtocolFactory,
};
use frugal::service::example;
use frugal::service::Request;
use frugal::transport::FTransport;

pub trait FBaseFoo {
    fn base_ping(&mut self, ctx: &FContext) -> thrift::Result<()>;
}

// TODO: client
pub struct FBaseFooClient<S>
where
    S: Service<Request = FBaseFooRequest, Response = FBaseFooResponse, Error = thrift::Error>,
{
    service: S,
}

impl<S> FBaseFooClient<S>
where
    S: Service<Request = FBaseFooRequest, Response = FBaseFooResponse, Error = thrift::Error>,
{
    //pub fn new() -> FBaseFooClient {
    //    unimplemented!()
    //}
}

impl<S> FBaseFoo for FBaseFooClient<S>
where
    S: Service<Request = FBaseFooRequest, Response = FBaseFooResponse, Error = thrift::Error>,
{
    fn base_ping(&mut self, ctx: &FContext) -> thrift::Result<()> {
        let request = FBaseFooRequest::new(
            ctx.clone(),
            FBaseFooMethod::BasePing(FBaseFooPingArgs::new()),
        );
        let result = self.service.call(request).wait()?;
        Ok(())
    }
}

pub struct FBaseFooClientService {
    transport: Box<dyn FTransport>,
    input_protocol_factory: FInputProtocolFactory,
    output_protocol_factory: FOutputProtocolFactory,
}

impl Service for FBaseFooClientService {
    type Request = FBaseFooRequest;
    type Response = FBaseFooResponse;
    type Error = thrift::Error;
    type Future = FutureResult<Self::Response, Self::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(&mut self, req: FBaseFooRequest) -> FutureResult<FBaseFooResponse, thrift::Error> {
        unimplemented!()
    }
}

pub struct FBaseFooPingArgs {}

impl FBaseFooPingArgs {
    pub fn new() -> FBaseFooPingArgs {
        FBaseFooPingArgs {}
    }

    fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }
}

pub struct FBaseFooPingResult {}

impl FBaseFooPingResult {
    pub fn new() -> FBaseFooPingResult {
        FBaseFooPingResult {}
    }

    fn write(&self, oprot: &mut FOutputProtocol) -> thrift::Result<()> {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("basePing_Result"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

pub struct FBaseFooProcessor<S>
where
    S: Service<Request = FBaseFooRequest, Response = FBaseFooResponse, Error = thrift::Error>,
{
    service: S,
}

pub struct FBaseFooProcessorBuilder<F, M>
where
    F: FBaseFoo,
{
    handler: F,
    middleware: M,
}

impl<F> FBaseFooProcessorBuilder<F, middleware::Identity>
where
    F: FBaseFoo,
{
    pub fn new(handler: F) -> Self {
        FBaseFooProcessorBuilder {
            handler,
            middleware: middleware::Identity::new(),
        }
    }
}

impl<F, M> FBaseFooProcessorBuilder<F, M>
where
    F: FBaseFoo,
{
    pub fn middleware<U>(
        self,
        middleware: U,
    ) -> FBaseFooProcessorBuilder<F, <M as Chain<U>>::Output>
    where
        M: Chain<U>,
    {
        FBaseFooProcessorBuilder {
            handler: self.handler,
            middleware: self.middleware.chain(middleware),
        }
    }

    pub fn build(self) -> FBaseFooProcessor<M::Service>
    where
        M: Middleware<
            FBaseFooProcessorService<F>,
            Request = FBaseFooRequest,
            Response = FBaseFooResponse,
            Error = thrift::Error,
        >,
    {
        FBaseFooProcessor {
            service: self.middleware.wrap(FBaseFooProcessorService(self.handler)),
        }
    }
}

pub struct FBaseFooRequest {
    ctx: FContext,
    method: FBaseFooMethod,
}

impl FBaseFooRequest {
    pub fn new(ctx: FContext, method: FBaseFooMethod) -> FBaseFooRequest {
        FBaseFooRequest { ctx, method }
    }
}

impl Request for FBaseFooRequest {
    fn context(&mut self) -> &mut FContext {
        &mut self.ctx
    }

    fn method_name(&self) -> &'static str {
        match self.method {
            FBaseFooMethod::BasePing(_) => "basePing",
        }
    }
}

pub enum FBaseFooMethod {
    BasePing(FBaseFooPingArgs),
}

pub enum FBaseFooResponse {
    BasePing(FBaseFooPingResult),
}

pub struct FBaseFooProcessorService<F: FBaseFoo>(F);

impl<F> Service for FBaseFooProcessorService<F>
where
    F: FBaseFoo,
{
    type Request = FBaseFooRequest;
    type Response = FBaseFooResponse;
    type Error = thrift::Error;
    type Future = FutureResult<Self::Response, Self::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(&mut self, req: FBaseFooRequest) -> FutureResult<FBaseFooResponse, thrift::Error> {
        let result = match req.method {
            FBaseFooMethod::BasePing(args) => self
                .0
                .base_ping(&req.ctx)
                .map(|res| FBaseFooResponse::BasePing(FBaseFooPingResult {})),
        };
        future::result(result)
    }
}

impl<S> FProcessor for FBaseFooProcessor<S>
where
    S: Service<Request = FBaseFooRequest, Response = FBaseFooResponse, Error = thrift::Error>,
{
    fn process(
        &mut self,
        iprot: &mut FInputProtocol,
        oprot: &mut FOutputProtocol,
    ) -> thrift::Result<()> {
        let ctx = iprot.read_request_header()?;
        let name = iprot.read_message_begin().map(|tmid| tmid.name)?;

        match &*name {
            "basePing" => self.base_ping(&ctx, iprot, oprot),
            _ => {
                error!(
                    "frugal: client invoked unknown function {} on request with correlation id {}",
                    &name,
                    ctx.correlation_id()
                );
                iprot.skip(thrift::protocol::TType::Struct)?;
                iprot.read_message_end()?;

                oprot.write_response_header(&ctx)?;
                oprot.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                    &name as &str,
                    thrift::protocol::TMessageType::Exception,
                    0,
                ))?;
                let ex = thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::UnknownMethod,
                    format!("Unknown function {}", &name),
                );
                thrift::Error::write_application_error_to_out_protocol(&ex, oprot)?;
                oprot.write_message_end()?;
                oprot.flush()
            }
        }
    }
}

impl<S> FBaseFooProcessor<S>
where
    S: Service<Request = FBaseFooRequest, Response = FBaseFooResponse, Error = thrift::Error>,
{
    fn base_ping(
        &mut self,
        ctx: &FContext,
        iprot: &mut FInputProtocol,
        oprot: &mut FOutputProtocol,
    ) -> thrift::Result<()> {
        let mut args = FBaseFooPingArgs {};
        args.read(iprot)?;
        iprot.read_message_end()?;
        let req = FBaseFooRequest {
            ctx: ctx.clone(),
            method: FBaseFooMethod::BasePing(args),
        };
        match self.service.call(req).wait() {
            Err(thrift::Error::User(err)) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Err(err) => {
                error!(
                    "{} {}: {}",
                    errors::USER_ERROR_DESCRIPTION,
                    ctx.correlation_id(),
                    err.description()
                );
                Ok(())
            }
            Ok(response) => {
                let write_result = oprot
                    .write_response_header(&ctx)
                    .and_then(|()| {
                        oprot.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                            "basePing",
                            thrift::protocol::TMessageType::Reply,
                            0,
                        ))
                    }).and_then(|()| {
                        let result = FBaseFooPingResult {};
                        result.write(oprot)
                    }).and_then(|()| oprot.write_message_end())
                    .and_then(|()| oprot.flush());

                match write_result {
                    Err(err) => {
                        if errors::is_too_large_error(&err) {
                            errors::write_application_error(
                                "basePing",
                                &ctx,
                                &thrift::ApplicationError::new(
                                    thrift::ApplicationErrorKind::Unknown,
                                    errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                                ),
                                oprot,
                            )
                        } else {
                            Err(err)
                        }
                    }
                    Ok(_) => Ok(()),
                }
            }
        }
    }
}
