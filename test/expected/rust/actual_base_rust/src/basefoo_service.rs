// Autogenerated by Frugal Compiler (3.3.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_variables)]

use std::any::Any;
use std::error::Error;
use std::sync::Arc;

use async_trait::async_trait;
use log::error;
use thrift;
use thrift::protocol::{TInputProtocol, TOutputProtocol};

use frugal::buffer::FMemoryOutputBuffer;
use frugal::context::FContext;
use frugal::errors;
use frugal::middleware::{self, Middleware};
use frugal::processor::FProcessor;
use frugal::protocol::{
    FInputProtocol, FInputProtocolFactory, FOutputProtocol, FOutputProtocolFactory,
};
use frugal::provider::FServiceProvider;
use frugal::transport::FTransport;

use super::*;

#[async_trait]
pub trait FBaseFoo {
    async fn base_ping(&self, ctx: &FContext) -> thrift::Result<()>;
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FBaseFooBasePingArgs {}

impl FBaseFooBasePingArgs {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("basePing_args"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

#[derive(Clone, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]
pub struct FBaseFooBasePingResult {}

impl FBaseFooBasePingResult {
    pub fn read<R, T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport,
        T: thrift::protocol::TInputProtocol<R>,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }

    pub fn write<W, T>(&self, oprot: &mut T) -> thrift::Result<()>
    where
        W: thrift::transport::TWriteTransport,
        T: thrift::protocol::TOutputProtocol<W>,
    {
        oprot.write_struct_begin(&thrift::protocol::TStructIdentifier::new("basePing_result"))?;
        oprot.write_field_stop()?;
        oprot.write_struct_end()
    }
}

struct BasePingMethod<F: FBaseFoo + Send + Sync>(F);

#[async_trait]
impl<F> middleware::Method for BasePingMethod<F>
where
    F: FBaseFoo + Send + Sync,
{
    async fn run(&self, req: middleware::Request) -> middleware::Response {
        let result = FBaseFooBasePingResult::default();
        let handled_result = self
            .0
            .base_ping(&req.ctx)
            .await
            .map(|res| Box::new(result) as Box<dyn Any + Send>);
        middleware::Response {
            result: handled_result,
        }
    }
}

pub struct FBaseFooClient<T>
where
    T: FTransport + Send + Sync,
{
    inner: FBaseFooClientInner<T>,
    middleware: Vec<Arc<dyn Middleware>>,
}

impl<T> FBaseFooClient<T>
where
    T: FTransport + Send + Sync,
{
    pub fn new(provider: FServiceProvider<T>) -> Self {
        FBaseFooClient {
            inner: FBaseFooClientInner { provider },
            middleware: Vec::new(),
        }
    }

    pub fn middleware(&mut self, middleware: impl Middleware) {
        self.middleware.push(Arc::new(middleware));
    }
}

// TODO: Figure out how to run the middleware somewhere on the client side
#[async_trait]
impl<T> FBaseFoo for FBaseFooClient<T>
where
    T: FTransport + Send + Sync,
{
    async fn base_ping(&self, ctx: &FContext) -> thrift::Result<()> {
        let args = FBaseFooBasePingArgs::default();

        let method = BasePingMethod(self.inner.clone());
        let middleware_next = middleware::Next {
            method: &method,
            next_middleware: &self.middleware,
        };
        let request = middleware::Request {
            ctx: ctx.clone(),
            args: Box::new(args),
        };
        middleware_next.run(request).await.result.map(|ok| {
            let result = ok
                .downcast::<FBaseFooBasePingResult>()
                .expect("expected an FBaseFooBasePingResult");
            ()
        })
    }
}

#[derive(Clone)]
struct FBaseFooClientInner<T>
where
    T: FTransport + Send + Sync,
{
    provider: FServiceProvider<T>,
}

#[async_trait]
impl<T> FBaseFoo for FBaseFooClientInner<T>
where
    T: FTransport + Send + Sync,
{
    async fn base_ping(&self, ctx: &FContext) -> thrift::Result<()> {
        let mut buffer = FMemoryOutputBuffer::new(0);
        let mut oprot = self
            .provider
            .output_protocol_factory
            .get_protocol(&mut buffer);
        {
            oprot.write_request_header(ctx)?;
            let mut oproxy = oprot.t_protocol_proxy();
            oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                "basePing",
                thrift::protocol::TMessageType::Call,
                0,
            ))?;
            let args = FBaseFooBasePingArgs {};
            args.write(&mut oproxy)?;
            oproxy.write_message_end()?;
            oproxy.flush()?;
        }
        let mut result_transport = match self.provider.transport.request(&ctx, buffer.bytes()).await
        {
            Ok(result_transport) => result_transport,
            Err(err) => return Err(err),
        };
        let mut iprot = self
            .provider
            .input_protocol_factory
            .get_protocol(&mut result_transport);
        // TODO: What context should we be using here?
        let mut octx = ctx.clone();
        iprot.read_response_header(&mut octx)?;
        let mut iproxy = iprot.t_protocol_proxy();
        let msg_id = iproxy.read_message_begin()?;
        if msg_id.name != "basePing" {
            return Err(thrift::new_application_error(
                thrift::ApplicationErrorKind::WrongMethodName,
                "basePing failed: wrong method name".to_string(),
            ));
        }
        match msg_id.message_type {
            thrift::protocol::TMessageType::Exception => {
                let err = thrift::Error::Application(
                    thrift::Error::read_application_error_from_in_protocol(&mut iproxy)?,
                );
                iproxy.read_message_end()?;
                if errors::is_too_large_error(&err) {
                    Err(thrift::new_transport_error(
                        thrift::TransportErrorKind::SizeLimit,
                        err.to_string(),
                    ))
                } else {
                    Err(err)
                }
            }
            thrift::protocol::TMessageType::Reply => {
                //let mut result = FBaseFooBasePingResult::default();
                //result.read(&mut iproxy)?;
                iproxy.read_message_end()?;
                Ok(())
            }
            _ => Err(thrift::new_application_error(
                thrift::ApplicationErrorKind::InvalidMessageType,
                "basePing failed: invalid message type".to_string(),
            )),
        }
    }
}

#[derive(Clone)]
pub struct FBaseFooProcessor<F>
where
    F: FBaseFoo + Send + Sync,
{
    handler: F,
    middleware: Vec<Arc<dyn Middleware>>,
}

impl<F> FBaseFooProcessor<F>
where
    F: FBaseFoo + Send + Sync,
{
    pub fn new(handler: F) -> Self {
        FBaseFooProcessor {
            handler,
            middleware: Vec::new(),
        }
    }

    pub fn middleware(&mut self, m: impl Middleware) {
        self.middleware.push(Arc::new(m));
    }
}

#[async_trait]
impl<F> FProcessor for FBaseFooProcessor<F>
where
    F: FBaseFoo + Clone + Send + Sync + 'static,
{
    async fn process<R, W>(
        &self,
        iprot: &mut FInputProtocol<R>,
        oprot: &mut FOutputProtocol<W>,
    ) -> thrift::Result<()>
    where
        R: thrift::transport::TReadTransport + Send,
        W: thrift::transport::TWriteTransport + Send,
    {
        let ctx = iprot.read_request_header()?;
        let name = {
            let mut iproxy = iprot.t_protocol_proxy();
            iproxy.read_message_begin().map(|tmid| tmid.name)?
        };

        match &*name {
            "basePing" => {
                server_base_ping(self.handler.clone(), &self.middleware, &ctx, iprot, oprot).await
            }
            _ => {
                error!(
                    "frugal: client invoked unknown function {} on request with correlation id {}",
                    &name,
                    ctx.correlation_id()
                );
                let mut iproxy = iprot.t_protocol_proxy();
                iproxy.skip(thrift::protocol::TType::Struct)?;
                iproxy.read_message_end()?;

                oprot.write_response_header(&ctx)?;
                let mut oproxy = oprot.t_protocol_proxy();
                oproxy.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                    &name as &str,
                    thrift::protocol::TMessageType::Exception,
                    0,
                ))?;
                let ex = thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::UnknownMethod,
                    format!("Unknown function {}", &name),
                );
                thrift::Error::write_application_error_to_out_protocol(&ex, &mut oproxy)?;
                oproxy.write_message_end()?;
                oproxy.flush()
            }
        }
    }
}

async fn server_base_ping<F, R, W>(
    handler: F,
    middleware_stack: &[Arc<dyn Middleware>],
    ctx: &FContext,
    iprot: &mut FInputProtocol<R>,
    oprot: &mut FOutputProtocol<W>,
) -> thrift::Result<()>
where
    F: FBaseFoo + Send + Sync,
    R: thrift::transport::TReadTransport,
    W: thrift::transport::TWriteTransport,
{
    let args = FBaseFooBasePingArgs::default();

    let method = BasePingMethod(handler);
    let middleware_next = middleware::Next {
        method: &method,
        next_middleware: middleware_stack,
    };
    let request = middleware::Request {
        ctx: ctx.clone(),
        args: Box::new(args),
    };
    let response = middleware_next.run(request).await;

    match response.result {
        Err(thrift::Error::User(err)) => {
            error!(
                "{} {}: {}",
                errors::USER_ERROR_DESCRIPTION,
                ctx.correlation_id(),
                err.description()
            );
            Ok(())
        }
        Err(err) => {
            error!(
                "{} {}: {}",
                errors::USER_ERROR_DESCRIPTION,
                ctx.correlation_id(),
                err.description()
            );
            Ok(())
        }
        Ok(result) => oprot
            .write_response_header(&ctx)
            .and_then(|()| {
                oprot.t_protocol_proxy().write_message_begin(
                    &thrift::protocol::TMessageIdentifier::new(
                        "basePing",
                        thrift::protocol::TMessageType::Reply,
                        0,
                    ),
                )
            })
            //.and_then(|()| result.write(&mut oprot.t_protocol_proxy()))
            .and_then(|()| oprot.t_protocol_proxy().write_message_end())
            .and_then(|()| oprot.t_protocol_proxy().flush())
            .or_else(|err| {
                if errors::is_too_large_error(&err) {
                    errors::write_application_error(
                        "basePing",
                        &ctx,
                        &thrift::ApplicationError::new(
                            thrift::ApplicationErrorKind::Unknown,
                            errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE,
                        ),
                        oprot,
                    )
                } else {
                    Err(err)
                }
            }),
    }
}
