// Autogenerated by Frugal Compiler (2.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

use std::collections::BTreeMap;
use std::error::Error;

use futures::future::{self, FutureResult};
use futures::{Async, Future, Poll};
use thrift;
use thrift::protocol::{TInputProtocol, TOutputProtocol};
use tower_service::Service;

use frugal::context::FContext;
use frugal::errors;
use frugal::processor::FProcessor;
use frugal::protocol::{
    FInputProtocol, FInputProtocolFactory, FOutputProtocol, FOutputProtocolFactory,
};
use frugal::service::Request;
use frugal::transport::FTransport;

pub trait FBaseFoo {
    fn base_ping(&self, ctx: &mut FContext) -> thrift::Result<()>;
}

pub struct FBaseFooClient {
    transport: Box<dyn FTransport>,
    input_protocol_factory: FInputProtocolFactory,
    output_protocol_factory: FOutputProtocolFactory,
}

impl FBaseFooClient {
    pub fn new() -> FBaseFooClient {
        unimplemented!()
    }
}

struct BaseFooPingArgs<'a> {
    ctx: &'a mut FContext,
}

impl<'a> BaseFooPingArgs<'a> {
    fn read<T>(&mut self, iprot: &mut T) -> thrift::Result<()>
    where
        T: thrift::protocol::TInputProtocol,
    {
        iprot.read_struct_begin()?;
        loop {
            let field_id = iprot.read_field_begin()?;
            if field_id.field_type == thrift::protocol::TType::Stop {
                break;
            };
            match field_id.id {
                _ => iprot.skip(field_id.field_type)?,
            };
            iprot.read_field_end()?;
        }
        iprot.read_struct_end()
    }
}

impl<'a> Request for BaseFooPingArgs<'a> {
    fn context(&mut self) -> &mut FContext {
        &mut self.ctx
    }

    fn method_name(&self) -> &'static str {
        "basePing"
    }
}

struct BaseFooPingResult {}

impl BaseFooPingResult {
    fn write(&self, oprot: &mut FOutputProtocol) -> thrift::Result<()> {
        Ok(())
    }
}

pub struct FBaseFooProcessor<F>
where
    F: FBaseFoo,
{
    handler: F,
}

impl<F> FBaseFooProcessor<F>
where
    F: FBaseFoo,
{
    //pub fn new<F, M>(handler: F, middleware: Vec<Box<dyn M>>) -> FBaseFooProcessor
    //where
    //    F: FBaseFoo,
    //    M: Service<
    //        Request = Req,
    //        Response = Res,
    //        Error = thrift::Error,
    //        Future = MethodFuture<Res>,
    //    >,
    //{
    //    unimplemented!()
    //}

    fn process_ping(
        &self,
        ctx: &mut FContext,
        iprot: &mut FInputProtocol,
        oprot: &mut FOutputProtocol,
    ) -> thrift::Result<()> {
        let response = {
            let mut args = BaseFooPingArgs { ctx: ctx };
            args.read(iprot)?;
            iprot.read_message_end()?;

            let mut ping_service = BaseFooPingService(&self.handler);
            // TODO: wrap ping_service in middleware

            ping_service.call(args).wait()
        };

        let mut result = BaseFooPingResult {};

        match response {
            Ok(_) => (),
            Err(thrift::Error::Application(ref err)) => {
                errors::write_application_error("basePing", ctx, err, oprot)?;
                return Ok(());
            }
            Err(err) => {
                let app_err = thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::InternalError,
                    format!("Internal error processing basePing: {}", err.description()),
                );
                errors::write_application_error("basePing", ctx, &app_err, oprot)?;
                return Err(err);
            }
        };
        oprot
            .write_response_header(ctx)
            .and_then(|()| result.write(oprot))
            .and_then(|()| oprot.write_message_end())
            .and_then(|()| oprot.flush())
            .map_err(|err| match err {
                thrift::Error::Transport(thrift::TransportError {
                    kind: thrift::TransportErrorKind::SizeLimit,
                    message: _,
                }) => {
                    let app_err = thrift::ApplicationError::new(
                        thrift::ApplicationErrorKind::Unknown,
                        errors::APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE.to_string(),
                    );
                    match errors::write_application_error("basePing", ctx, &app_err, oprot) {
                        Ok(()) => thrift::Error::Application(app_err),
                        Err(err) => err,
                    }
                }
                err => err,
            })
    }
}

struct BaseFooPingService<'a, F: FBaseFoo + 'a>(&'a F);

impl<'a, F> Service for BaseFooPingService<'a, F>
where
    F: FBaseFoo + 'a,
{
    type Request = BaseFooPingArgs<'a>;
    type Response = ();
    type Error = thrift::Error;
    type Future = FutureResult<(), thrift::Error>;

    fn poll_ready(&mut self) -> Poll<(), thrift::Error> {
        Ok(Async::Ready(()))
    }

    fn call(&mut self, req: BaseFooPingArgs<'a>) -> FutureResult<(), thrift::Error> {
        future::result(self.0.base_ping(req.ctx))
    }
}

impl<F> FProcessor for FBaseFooProcessor<F>
where
    F: FBaseFoo,
{
    fn process(
        &self,
        iprot: &mut FInputProtocol,
        oprot: &mut FOutputProtocol,
    ) -> thrift::Result<()> {
        let mut ctx = iprot.read_request_header()?;
        let name = iprot.read_message_begin().map(|tmid| tmid.name)?;

        match &*name {
            "basePing" => {
                match self.process_ping(&mut ctx, iprot, oprot) {
                    Err(thrift::Error::User(err)) => error!("frugal: user handler code returned unhandled error on request with correlation id {}: {}", ctx.correlation_id(), err.description()),
                    Err(err) => error!("frugal: user handler code returned unhandled error on request with correlation id {}: {}", ctx.correlation_id(), err.description()),
                    _ => (),
                };
                // Return Ok because the server should still send a response to the client.
                Ok(())
            }
            _ => {
                error!(
                    "frugal: client invoked unknown function {} on request with correlation id {}",
                    &name,
                    ctx.correlation_id()
                );
                iprot.skip(thrift::protocol::TType::Struct)?;
                iprot.read_message_end()?;

                oprot.write_response_header(&ctx)?;
                oprot.write_message_begin(&thrift::protocol::TMessageIdentifier::new(
                    &name as &str,
                    thrift::protocol::TMessageType::Exception,
                    0,
                ))?;
                let ex = thrift::ApplicationError::new(
                    thrift::ApplicationErrorKind::UnknownMethod,
                    format!("Unknown function {}", &name),
                );
                thrift::Error::write_application_error_to_out_protocol(&ex, oprot)?;
                oprot.write_message_end()?;
                oprot.flush()
            }
        }
    }
}
