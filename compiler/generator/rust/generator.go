/*
 * Copyright 2017 Workiva
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rust

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/globals"
	"github.com/Workiva/frugal/compiler/parser"
)

const (
	lang             = "rs"
	defaultOutputDir = "gen-rs"
	serviceSuffix    = "_service"
	scopeSuffix      = "_scope"

	packageTypeOption = "package_type"
)

type packageType string

const (
	packageTypeCrate  = "crate"
	packageTypeModule = "module"
)

func newPackageType(p string) packageType {
	switch p {
	case string(packageTypeModule):
		return packageTypeModule
	default:
		return packageTypeCrate
	}
}

func (p packageType) fileName() string {
	switch p {
	case packageTypeModule:
		return "mod"
	default:
		return "lib"
	}
}

func (p packageType) outputDir(outputDir string) string {
	switch p {
	case packageTypeModule:
		return outputDir
	default:
		return outputDir + "/src"
	}
}

func (p packageType) generateCargoTOML() bool {
	switch p {
	case packageTypeModule:
		return false
	default:
		return true
	}
}

type Generator struct {
	*generator.BaseGenerator
	rootFile    *os.File
	packageType packageType
}

func NewGenerator(options map[string]string) generator.LanguageGenerator {
	return &Generator{
		BaseGenerator: &generator.BaseGenerator{Options: options},
		rootFile:      nil,
		packageType:   newPackageType(options[packageTypeOption]),
	}
}

func (g *Generator) SetupGenerator(outputDir string) error {
	rootFile, err := g.CreateFile(
		g.packageType.fileName(), g.packageType.outputDir(outputDir), lang, false)
	if err != nil {
		return err
	}
	g.rootFile = rootFile
	if err = g.GenerateDocStringComment(g.rootFile); err != nil {
		return err
	}
	if err = g.GenerateNewline(g.rootFile, 2); err != nil {
		return err
	}
	// TODO: externs go here
	return nil
}

func (g *Generator) TeardownGenerator() error {
	defer g.rootFile.Close()
	return g.PostProcess(g.rootFile)
}

func (g *Generator) GetOutputDir(dir string) string {
	// TODO: is this logic correct for rust? it was copied from Go
	if namespace := g.Frugal.Namespace(lang); namespace != nil {
		path := generator.GetPackageComponents(namespace.Value)
		dir = filepath.Join(append([]string{dir}, path...)...)
	} else {
		dir = filepath.Join(dir, g.Frugal.Name)
	}
	return dir
}

func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

func (g *Generator) PostProcess(f *os.File) error {
	// TODO: mabye run rustfmt?
	return nil
}

func (g *Generator) GenerateDependencies(dir string) error {
	if !g.packageType.generateCargoTOML() {
		return nil
	}

	cargoFile, err := g.CreateFile("Cargo", dir, "toml", false)
	if err != nil {
		return err
	}
	cargoFile.WriteString(fmt.Sprintf(`[package]
name = %q
version = %q

[dependencies]`, g.Frugal.Name, globals.Version))
	return cargoFile.Close()
}

func (g *Generator) GenerateFile(name, outputDir string, fileType generator.FileType) (*os.File, error) {
	switch fileType {
	case generator.CombinedServiceFile:
		return g.CreateFile(strings.ToLower(name)+serviceSuffix, g.packageType.outputDir(outputDir), lang, false)
	case generator.CombinedScopeFile:
		return g.CreateFile(strings.ToLower(name)+scopeSuffix, g.packageType.outputDir(outputDir), lang, false)
	default:
		return nil, fmt.Errorf("Bad file type for rust generator: %s", fileType)
	}
}

// GenerateDocStringComment generates the autogenerated notice.
func (g *Generator) GenerateDocStringComment(file *os.File) error {
	comment := fmt.Sprintf(
		`// Autogenerated by Frugal Compiler (%s)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

//! # %s`,
		globals.Version,
		strings.Title(g.Frugal.Name))

	_, err := file.WriteString(comment)
	return err
}

// GenerateServicePackage generates the package for the given service.
func (g *Generator) GenerateServicePackage(file *os.File, s *parser.Service) error {
	return nil
}

// GenerateScopePackage generates the package for the given scope.
func (g *Generator) GenerateScopePackage(file *os.File, s *parser.Scope) error {
	return nil
}

func (g *Generator) generateRustLiteral(t *parser.Type, value interface{}) string {
	return ""
}

func (g *Generator) GenerateConstantsContents(constants []*parser.Constant) error {
	var buffer bytes.Buffer
	for _, constant := range constants {
		for _, comment := range constant.Comment {
			buffer.WriteString(fmt.Sprintf("// %s\n", comment))
		}
		// pub const NAME: TYPE = VALUE;
		// or
		// pub static NAME: TYPE = VALUE: Are statics only needed for containers?
		if !constant.Type.IsContainer() {
			t := constant.Type
			//if t == "string" {
			//	t = "&'static str"
			//} else if t == "binary" {
			//	t = "&'static [u8]"
			//}
			// TODO: Replace with generateRustLiteral
			buffer.WriteString(fmt.Sprintf("pub const %s: %s = %v;\n\n", constant.Name, t, constant.Value))
		}
	}
	g.rootFile.Write(buffer.Bytes())
	return nil
}

func (g *Generator) GenerateTypeDef(typedef *parser.TypeDef) error {
	return nil
}

func (g *Generator) GenerateEnum(enum *parser.Enum) error {
	return nil
}

func (g *Generator) GenerateStruct(s *parser.Struct) error {
	return nil
}

func (g *Generator) GenerateUnion(union *parser.Struct) error {
	return nil
}

func (g *Generator) GenerateException(exception *parser.Struct) error {
	return nil
}

func (g *Generator) GenerateTypesImports(file *os.File) error {
	return nil
}

func (g *Generator) GenerateServiceResultArgsImports(file *os.File) error { return nil }

func (g *Generator) GenerateServiceImports(file *os.File, s *parser.Service) error { return nil }

func (g *Generator) GenerateScopeImports(file *os.File, s *parser.Scope) error { return nil }

func (g *Generator) GenerateConstants(file *os.File, name string) error { return nil }

func (g *Generator) GeneratePublisher(file *os.File, scope *parser.Scope) error { return nil }

func (g *Generator) GenerateSubscriber(file *os.File, scope *parser.Scope) error { return nil }

func (g *Generator) GenerateService(file *os.File, s *parser.Service) error { return nil }
